<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>02 计算机体系结构 | 李瑞琦的博客</title><meta name="author" content="Li Ruiqi"><meta name="copyright" content="Li Ruiqi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="计算机体系结构基本概念体系结构vs组成原理 体系结构：能被程序员看到的计算机系统的属性，即概念性的结构和功能特性（主要是被汇编程序员所看到的属性，包括指令集、数据类型、存储器寻址技术、IO机理等…）  示例：  冯诺依曼架构  哈佛架构  核心内容：  多核协同：一致性协议（如 MESI）、互联总线（如 AMBA ACE）  内存子系统：NUMA 支持、内存控制器设计  外设与扩展：PCIe、US">
<meta property="og:type" content="article">
<meta property="og:title" content="02 计算机体系结构">
<meta property="og:url" content="https://li-ruiqi777.github.io/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html">
<meta property="og:site_name" content="李瑞琦的博客">
<meta property="og:description" content="计算机体系结构基本概念体系结构vs组成原理 体系结构：能被程序员看到的计算机系统的属性，即概念性的结构和功能特性（主要是被汇编程序员所看到的属性，包括指令集、数据类型、存储器寻址技术、IO机理等…）  示例：  冯诺依曼架构  哈佛架构  核心内容：  多核协同：一致性协议（如 MESI）、互联总线（如 AMBA ACE）  内存子系统：NUMA 支持、内存控制器设计  外设与扩展：PCIe、US">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://li-ruiqi777.github.io/img/head.png">
<meta property="article:published_time" content="2025-06-04T08:29:12.402Z">
<meta property="article:modified_time" content="2025-09-26T01:34:49.708Z">
<meta property="article:author" content="Li Ruiqi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://li-ruiqi777.github.io/img/head.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://li-ruiqi777.github.io/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '02 计算机体系结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7.0/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/jetbrains-mono@4.5.12/index.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(135deg, #a9d6e0 0%, #e0f7fa 100%);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">19</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">李瑞琦的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">02 计算机体系结构</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">02 计算机体系结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-06-04T08:29:12.402Z" title="Created 2025-06-04 16:29:12">2025-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-09-26T01:34:49.708Z" title="Updated 2025-09-26 09:34:49">2025-09-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/">01-计算机基础八股</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="体系结构vs组成原理"><a href="#体系结构vs组成原理" class="headerlink" title="体系结构vs组成原理"></a>体系结构vs组成原理</h3><ul>
<li><p>体系结构：能被程序员看到的计算机系统的属性，即<strong>概念性</strong>的结构和功能特性（主要是被汇编程序员所看到的属性，包括指令集、数据类型、存储器寻址技术、IO机理等…）</p>
<ul>
<li><p>示例：</p>
<ul>
<li><p>冯诺依曼架构</p>
</li>
<li><p>哈佛架构</p>
</li>
<li><p>核心内容：</p>
<ul>
<li><p>多核协同：一致性协议（如 MESI）、互联总线（如 AMBA ACE）</p>
</li>
<li><p>内存子系统：NUMA 支持、内存控制器设计</p>
</li>
<li><p>外设与扩展：PCIe、USB 控制器、加速器（如 NPU）的集成</p>
</li>
<li><p>安全与虚拟化：TrustZone、IOMMU、虚拟化扩展（如 ARM SMMU）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>组成原理：指<strong>如何实现</strong>计算机体系结构所体现的属性，它包含了很多对程序员来说是透明的硬件细节。比如规定一台计算机有哪些属性属于体系结构的问题，但如何通过电路实现这些指令，属于组成原理的问题</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>体系结构</th>
<th>组成原理</th>
</tr>
</thead>
<tbody><tr>
<td>关注点</td>
<td>软件可见的属性</td>
<td>硬件如何实现这些属性</td>
</tr>
<tr>
<td>面向对象</td>
<td>程序员 &#x2F; 编译器</td>
<td>硬件工程师</td>
</tr>
<tr>
<td>内容</td>
<td>指令集、寄存器、内存模型</td>
<td>流水线、Cache、总线、预测</td>
</tr>
<tr>
<td>稳定性</td>
<td>长期稳定（几十年不变）</td>
<td>厂商私有，频繁迭代</td>
</tr>
<tr>
<td>举例</td>
<td>RISC-V 指令集、ARMv8 ISA</td>
<td>Cortex-A72 的流水线设计</td>
</tr>
</tbody></table>
<p>参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/626219916/answer/3250815167">计算机组成与计算机体系结构有什么区别？ - 知乎</a></li>
</ul>
<h3 id="CPU-SoC-MCU-MPU的区别"><a href="#CPU-SoC-MCU-MPU的区别" class="headerlink" title="CPU&#x2F;SoC&#x2F;MCU&#x2F;MPU的区别"></a>CPU&#x2F;SoC&#x2F;MCU&#x2F;MPU的区别</h3><ul>
<li><p>CPU就是上面提到的CPU内核，包括运算器、控制器、寄存器、Cache等</p>
</li>
<li><p>SoC是将一个完整的系统整合到<strong>单一芯片</strong>上的集成电路，包括 CPU、GPU、存储控制器、外设接口、专用加速器(GPU&#x2F;NPU&#x2F;VOP)等</p>
<ul>
<li>SoC 不一定有片上 RAM（有些会集成 LPDDR），但一定有外部内存接口</li>
</ul>
</li>
<li><p>MCU是一种集成了CPU、内存（如闪存、RAM）、以及多种外设（如ADC、DAC、串行通信接口、定时器等）于一体的芯片，可以看成<strong>简易版的SoC</strong>。与SoC的核心区别：</p>
<ul>
<li><p>MCU通常不跑复杂OS(最多RTOS)，但是SoC一般跑Linux&#x2F;Android之类的</p>
</li>
<li><p>MCU的片上RAM&#x2F;ROM都比较小，功耗比较低</p>
</li>
</ul>
</li>
<li><p>MPU：不带片上 Flash&#x2F;RAM，需要外部存储器的处理器芯片，一般只包括CPU核心+外设控制器，必须配合外部的RAM+ROM才能运行，适合跑Linux&#x2F;Android之类的复杂操作系统。（注意：ARM里还有个叫内存保护单元的MPU，和这里不是一个东西）</p>
</li>
</ul>
<p>x86架构的电脑通常会有个主板，将CPU芯片和各个外设芯片通过总线连接，而嵌入式系统的SOC&#x2F;MCU是把CPU和各个外设都集成到了一个芯片里，这是他们很大的一个区别</p>
<p><img src="../assets/image-20241211101851896.png" alt="image-20241211101851896" style="zoom:50%;" /><img src="../assets/image-20241211101903102.png" alt="image-20241211101903102" style="zoom: 50%;" /><img src="../assets/image-20241211101954770.png" alt="image-20241211101954770" style="zoom: 50%;" /></p>
<p>MCU和SoC的区别主要体现在：</p>
<ul>
<li>处理能力</li>
<li>应用场景</li>
<li>功耗</li>
<li>集成度：MCU集成的资源有限，主要用于控制任务，而非复杂计算；而SOC通常是一个完整的系统集成在一块芯片上，集成度更高，比如有MCU上没有的屏幕驱动部分、GPU等</li>
</ul>
<img src="../assets/image-20240901211121011.png" alt="image-20240901211121011" style="zoom:67%;" />

<p>由于SOC中集成了很多模块，那么软硬件工程师的工作量也会减少，如果用裸CPU，那么什么RAM、FLASH的电路都得自己画，但是如果SOC自带了，那么就不需要了啊</p>
<h3 id="ARM授权模式"><a href="#ARM授权模式" class="headerlink" title="ARM授权模式"></a>ARM授权模式</h3><p>ARM公司其实是CPU内核的设计厂商，只做CPU内核的设计（IP核），并不制造芯片本身。我们经常听到ARM架构，那么为什么别的芯片公司都能用ARM架构的CPU呢？</p>
<p>而其他半导体厂商，比如ST、华为之类的，要生产的SOC肯定里面要用到CPU内核，那么就得向ARM公司买他们设计好的内核（可以理解为ARM只卖DNF装备的设计图）</p>
<p>授权又分为多种：</p>
<ul>
<li>ISA层级授权：可以对ARM内核进行大幅度改造，甚至可以修改指令集，总而得到一个新的架构（苹果的Swift架构）</li>
<li>微架构层级授权：可以以ARM内核为基础再加上自己的外设，最后形成一个MCU或SOC（TI、ST公司）</li>
<li>使用层级授权：只能把定义好的IP核拿来用，不能修改或再封装自己的产品</li>
</ul>
<img src="../assets/image-20240901212713201.png" alt="image-20240901212713201" style="zoom:50%;" />



<h2 id="其他的一些概念"><a href="#其他的一些概念" class="headerlink" title="其他的一些概念"></a>其他的一些概念</h2><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><ul>
<li><p>定义：CPU能够执行的所有机器指令的集合，是软件与硬件交互的基础规范。例如：x86支持复杂指令（如MMX、AVX），ARM支持精简指令（Thumb-2）</p>
</li>
<li><p>分类：</p>
<ul>
<li><p>CISC（复杂指令集）：针对每一种功能都实现特定的指令，导致指令的数量较多，但生成的程序长度较短</p>
</li>
<li><p>RISC（精简指令集）：只实现基本的指令，复杂的指令由基本指令组成，这导致指令的数目较少，但生成的程序长度较长</p>
</li>
</ul>
</li>
</ul>
<h3 id="机器指令、汇编、编程语言的区别"><a href="#机器指令、汇编、编程语言的区别" class="headerlink" title="机器指令、汇编、编程语言的区别"></a>机器指令、汇编、编程语言的区别</h3><ul>
<li><p>指令集：**一个CPU真正支持的所有操作的&#x3D;&#x3D;集合&#x3D;&#x3D;**。它定义了 CPU 能够执行的指令类型、每条指令的操作码及其格式、操作数类型等。不同架构的CPU（x86、ARM、MIPS等）的主要区别之一就是指令集不同</p>
</li>
<li><p>机器指令：机器指令是CPU可以直接运行的二进制代码，一条机器指令就是指令集中的一条元素，对应CPU支持的特定操作，例如数据传送、算术运算、逻辑操作、控制流等</p>
</li>
<li><p>汇编语言：汇编语言是对机器指令的一种封装，使得用户可读（机器指令是二进制的，用户不可读），汇编是个动词，指的是将汇编语言转成CPU可以运行的机器指令。汇编这个过程类似编译，也需要一个程序（汇编程序）来完成，汇编相较于编译更为简单，通常只涉及将汇编指令映射为机器码。</p>
</li>
</ul>
<blockquote>
<p>由此可见汇编不具有跨平台的特性，在X86架构的CPU写的汇编，拿到ARM架构的CPU大概率不可用，因为指令集都不一样</p>
</blockquote>
<h3 id="汇编中指令和伪指令的区别"><a href="#汇编中指令和伪指令的区别" class="headerlink" title="汇编中指令和伪指令的区别"></a>汇编中指令和伪指令的区别</h3><ul>
<li>指令：对应于CPU支持的机器指令，汇编时直接映射为机器码</li>
<li>伪指令：辅助汇编程序编写和组织代码的数据定义和控制指令，不对应于CPU支持的机器指令，汇编时被转换为几条机器码</li>
</ul>
<h2 id="指令集架构-ISA"><a href="#指令集架构-ISA" class="headerlink" title="指令集架构(ISA)"></a>指令集架构(ISA)</h2><img src="../assets/image-20241209115112416.png" alt="image-20241209115112416" style="zoom:50%;" />

<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul>
<li>定义：规定了CPU对程序员可见的功能和行为，包含指令集、寄存器组织、内存模型、寻址方式、异常或中断的处理方式、软硬件接口、特权模式等的完整规范，是&#x3D;&#x3D;CPU&#x3D;&#x3D;设计的<strong>抽象类</strong>，可以理解为他就是个文档，且<strong>不包括</strong>具体的电路实现</li>
</ul>
<blockquote>
<p>指令集架构只是一种规范和约束，让编程者无需关心底层的硬件电路。</p>
<ul>
<li>可以理解为指令集(架构)相当于抽象类，硬件电路为子类具体的实现</li>
</ul>
<p>我们常说的CPU的架构其实就是指的是CPU的指令集架构（ISA），比如x86_64、ARMv7a、ARMv7m..</p>
</blockquote>
<ul>
<li>核心内容：<ul>
<li>指令集：属于RISC还是CISC、支持的指令（如 <code>ADD</code>、<code>MOV</code>）、指令格式、操作数类型</li>
<li>寄存器结构：通用寄存器、状态寄存器（如 <code>x86</code> 的 <code>EFLAGS</code>、<code>ARM</code> 的 <code>CPSR</code>），各寄存器宽度</li>
<li>内存管理：虚拟内存映射，地址空间、对齐要求、内存访问语义、字节序</li>
<li>异常与中断模型：异常类型（如缺页、非法指令）、处理流程</li>
<li>特权级别：定义特权模式（如 <code>x86</code> 的 <code>Ring 0-3</code>、<code>ARM</code> 的 <code>EL0-EL3</code>）</li>
<li>可选拓展：SIMD、虚拟化、DSP…</li>
</ul>
</li>
</ul>
<p>不同ISA包含的内容不完全一样：</p>
<img src="../assets/image-20250503155818886.png" alt="image-20250503155818886" style="zoom:50%;" />

<blockquote>
<p>RISC-V、ARM其实都是ISA的统称，具体的ISA应该是RV32IA、ARMv7-M这样的</p>
</blockquote>
<ul>
<li>实例：<ul>
<li><p>RISC-V：开源指令集架构，可扩展性强（RISC-V其实也是<strong>统称</strong>，它有很多具体版本比如RV32I）</p>
</li>
<li><p>ARMv8-A：支持64位计算，定义AArch64执行状态和异常模型</p>
</li>
</ul>
</li>
</ul>
<h3 id="ISA的宽度"><a href="#ISA的宽度" class="headerlink" title="ISA的宽度"></a>ISA的宽度</h3><p>定义：指的是CPU中通用寄存器的宽度（二进制的位数），这决定了寻址范围的大小，以及数据运算的能力。这与指令的宽度不同，比如RISCV架构CPU有32位也有64位，但指令的宽度都是32位。</p>
<h2 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h2><p>现在的SoC或者MCU内，都会有中断控制器，它们负责接收、筛选和派发中断给CPU。这个中断控制器可能被集成在CPU内核内（比如NVIC），也可能在CPU外部作为一个独立的IP核（比如GIC、PLIC）</p>
<p>中断控制器有点类似CPU内核，也是遵循“公开的规范 + 私有的实现”的形式</p>
<p>我们之前经常看到的被ARMv7-M使用的NVIC中断控制器，ARMv7-A使用的GIC中断控制器，其实都是由ARM提出的一个&#x3D;&#x3D;规范&#x3D;&#x3D;（例如GICv1, v2, v3, v4）</p>
<p>这份规范详细规定了：</p>
<ul>
<li>功能模型：中断的生命周期（产生、分发、优先级仲裁、应答、结束）</li>
<li>编程接口：软件（操作系统、驱动程序）如何与GIC交互。这包括：<ul>
<li>寄存器接口：定义了控制寄存器组（如GICD_、GICC_等）的功能、地址映射和访问方式</li>
<li>中断类型：SGI（软件生成中断）、PPI（私有外设中断）、SPI（共享外设中断）等的定义和行为</li>
<li>中断状态机：每个中断所处的状态（ inactive, pending, active, active and pending）</li>
</ul>
</li>
<li>兼容性要求：确保任何遵循此规范的GIC实现，都能被同一版本的软件驱动正确操作</li>
</ul>
<blockquote>
<p>从程序员的角度来看，只要2个SoC用的都是GIC标准，那么对其寄存器地址、优先级配置方法、中断开关流程的配置应该都是一样的，但是硬件上大概率是不一样的</p>
</blockquote>
<p>各芯片厂商在获得ARM的授权后，会根据这份规范，用自己的方式设计出具体的GIC硬件电路，比如：</p>
<ul>
<li>Nvidia Tegra X1实现了 GIC-400（基于GICv2架构）</li>
<li>Qualcomm Snapdragon 8 Gen 2 手机芯片实现了基于 GICv3 或 GICv4 架构的自研GIC</li>
</ul>
<h2 id="CPU内核-微架构"><a href="#CPU内核-微架构" class="headerlink" title="CPU内核&#x2F;微架构"></a>CPU内核&#x2F;微架构</h2><ul>
<li>英文：CPU Core&#x2F;Microarchitecture</li>
</ul>
<p>前面提到了ISA层只是给出了一些接口规范，但具体实现是需要各个厂家通过具体的硬件电路来做，这属于ISA层之下的MicroArchtecture层</p>
<p>比如常见的ISA的实现有x86、ARM、RISC-V、MIPS…，但是ISA的实现也只是给出了一些规范和接口，后面就是通过硬件电路实现这些接口：ARM的Cortex系列，玄铁做的C906…</p>
<blockquote>
<p>这种 “规范 + 实现” 的方式在其他领域也可以看见！</p>
</blockquote>
<img src="../assets/image-20241209120423829.png" alt="image-20241209120423829" style="zoom:50%;" />




<ul>
<li><p>定义：CPU内核是对ISA的&#x3D;&#x3D;具体实现&#x3D;&#x3D;，并关注性能、功耗、面积等优化。一般以IP核的形式提供给SOC厂商，IP核又分为<strong>软核</strong>（提供RTL级实现）和<strong>硬核</strong>（提供电路布局级实现）。如果有了软核，可以直接将RTL映射至FPGA，即可用FPGA进行物理时序的验证</p>
</li>
<li><p>核心内容：</p>
<ul>
<li>流水线设计：级数、乱序执行（如 Intel 的 <code>Out-of-Order</code>）、分支预测策略</li>
<li>缓存层次：各级Cache的大小、替换算法（如 LRU）</li>
<li>并行计算单元：超标量（Superscalar）、SIMD（如 NEON&#x2F;AVX）</li>
<li>功耗管理：动态电压频率调整（DVFS）、时钟门控</li>
<li>物理设计：晶体管布局、时序优化</li>
</ul>
</li>
<li><p>实例:</p>
<ul>
<li>Cortex-A77 是 基于ARMv8-A 的一种CPU内核，采用 4 宽解码、128 ROB（重排序缓冲区）</li>
<li>Apple M1 基于 ARMv8.5-A ISA，但使用自研 Firestorm&#x2F;Icestorm 微架构</li>
<li>玄铁C906是RISCV64GCBV ISA的CPU内核</li>
</ul>
</li>
</ul>
<img src="../assets/image-20250510203628233.png" alt="image-20250510203628233" style="zoom:80%;" />


<p>关系与对比</p>
<table>
<thead>
<tr>
<th align="center">层级</th>
<th align="center">定义范围</th>
<th align="center">稳定性</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ISA</td>
<td align="center">指令、寄存器、内存模型</td>
<td align="center">长期稳定</td>
<td align="center">ARMv8-A、RISC-V</td>
</tr>
<tr>
<td align="center">Microarchitecture</td>
<td align="center">流水线、缓存、功耗优化</td>
<td align="center">厂商私有，频繁迭代</td>
<td align="center">Cortex-A78、Apple M2</td>
</tr>
<tr>
<td align="center">Architecture</td>
<td align="center">多核、总线、外设集成</td>
<td align="center">依赖生态需求</td>
<td align="center">AMBA 总线、Intel Hybrid 架构</td>
</tr>
</tbody></table>
<blockquote>
<p>以“实现内存映射这一目”为例，看一下不同层级分别负责哪些内容</p>
</blockquote>
<p>1.ISA层级：只规定内存映射机制，不涉及具体硬件实现</p>
<ul>
<li><p>地址转换机制：规定是否支持分页（如 ARMv8-A 的 4KB&#x2F;64KB 页）、页表格式（如 ARM 的 <code>Descriptor Table</code>）</p>
</li>
<li><p>特权控制：定义哪些指令&#x2F;模式可访问页表（如 <code>x86</code> 的 <code>CR3</code> 寄存器、<code>ARM</code> 的 <code>TTBR0</code>）</p>
</li>
<li><p>异常类型：触发缺页异常（Page Fault）的条件（如权限错误、非法地址）</p>
</li>
<li><p>示例：</p>
<ul>
<li>ARMv8-A 要求 MMU 支持 48 位虚拟地址和 4 级页表</li>
<li>RISC-V 的 <code>Sv39</code> 模式定义三级页表结构</li>
</ul>
</li>
</ul>
<p>2.微架构层级：决定 MMU 具体实现与优化，是厂商优化的重点</p>
<ul>
<li>TLB设计：容量方式（全关联&#x2F;组相联）、替换策略（LRU&#x2F;Random）</li>
<li>多级页表缓存：硬件预取页表项（如 ARM 的 <code>Walk Cache</code>）</li>
<li>并行查表：支持多级页表并行访问以降低延迟</li>
<li>物理实现：与流水线的协同（如 MMU 与 Load&#x2F;Store 单元的交互）</li>
<li>示例：<ul>
<li>Intel Skylake 的 MMU 采用 多级 TLB（L1&#x2F;L2）和 硬件页表遍历器</li>
<li>Cortex-A72 的 MMU 支持 2MB 大页缓存以减少 TLB 缺失</li>
</ul>
</li>
</ul>
<p>3.体系结构层级：关注 MMU 在系统中的角色，而非具体电路设计</p>
<ul>
<li>总线协议：MMU 如何与系统总线（如 AMBA AXI）交互</li>
<li>多核一致性：MMU 在 Cache 一致性中的作用（如 ARM 的 <code>SCU</code> 监听控制）</li>
<li>安全扩展：MMU 如何支持 TrustZone 或虚拟化（如第二阶段地址转换）</li>
</ul>
<h2 id="ARMv7-A"><a href="#ARMv7-A" class="headerlink" title="ARMv7-A"></a>ARMv7-A</h2><p>ARMv7 ISA其实有多个不同的版本</p>
<table>
<thead>
<tr>
<th></th>
<th>ARMv7-A</th>
<th>ARMv7-R</th>
<th>ARMv7-M</th>
</tr>
</thead>
<tbody><tr>
<td>应用场景</td>
<td>应用处理器，高性能 OS</td>
<td>实时控制</td>
<td>微控制器，低功耗</td>
</tr>
<tr>
<td>MMU&#x2F;MPU</td>
<td>有 MMU</td>
<td>MPU</td>
<td>MPU</td>
</tr>
<tr>
<td>指令集</td>
<td>ARM + Thumb</td>
<td>ARM + Thumb</td>
<td>Thumb &#x2F; Thumb-2</td>
</tr>
<tr>
<td>常见 CPU 核心</td>
<td>Cortex-A8&#x2F;A9&#x2F;A53</td>
<td>Cortex-R4&#x2F;R5</td>
<td>Cortex-M0&#x2F;M3&#x2F;M4</td>
</tr>
</tbody></table>
<p>之前用的ARM Cortex A7的CPU内核的指令集架构是ARMv7A，现在对该ISA进行分析</p>
<h3 id="特权等级"><a href="#特权等级" class="headerlink" title="特权等级"></a>特权等级</h3><p>与RISCV的特权等级单一分层不同，ARMv7A使用了两层分层模型（特权等级+处理器模式）来设计</p>
<p>具体地，包含7种工作模式（分为2种特权等级），每个特权等级对应不同的处理器工作模式：</p>
<ul>
<li>非特权等级（Unprivileged）：仅 <code>User</code>模式</li>
<li>特权等级（Privileged）：所有其他模式</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
<th>特权级别</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td>User (USR)</td>
<td>普通用户模式</td>
<td>用户</td>
<td>应用程序执行</td>
</tr>
<tr>
<td>FIQ (Fast Interrupt)</td>
<td>快速中断模式</td>
<td>特权</td>
<td>高速中断处理</td>
</tr>
<tr>
<td>IRQ (Interrupt)</td>
<td>普通中断模式</td>
<td>特权</td>
<td>中断处理</td>
</tr>
<tr>
<td>Supervisor (SVC)</td>
<td>监控模式</td>
<td>特权</td>
<td>OS 内核、系统调用</td>
</tr>
<tr>
<td>Abort (ABT)</td>
<td>内存访问异常（预取&#x2F;数据）模式</td>
<td>特权</td>
<td>异常处理</td>
</tr>
<tr>
<td>Undefined (UND)</td>
<td>未定义指令模式</td>
<td>特权</td>
<td>异常处理</td>
</tr>
<tr>
<td>System (SYS)</td>
<td>内核模式，运行在特权级别的用户模式</td>
<td>特权</td>
<td>内核线程运行</td>
</tr>
</tbody></table>
<blockquote>
<p>小技巧记忆：</p>
<ul>
<li>User &#x3D; 应用程序执行</li>
<li>FIQ&#x2F;IRQ &#x3D; 中断处理</li>
<li>SVC&#x2F;System &#x3D; OS 内核</li>
<li>Abort&#x2F;Undefined &#x3D; 异常处理</li>
</ul>
</blockquote>
<ul>
<li><p>User：用户程序的工作模式，运行在操作系统的<strong>用户态</strong>，所以没有权限操作硬件资源</p>
<ul>
<li>无法直接切换到别的模式，如果想要访问硬件或者切换到别的模式，只能通过<strong>软中断</strong>（SWI指令）或者<strong>异常</strong></li>
</ul>
</li>
<li><p>IRQ：普通中断模式，用于处理一般的中断请求，延迟稍高于 FIQ</p>
<ul>
<li>R8–R12 与其他模式<strong>共享</strong>，需要保存&#x2F;恢复通用寄存器</li>
</ul>
</li>
<li><p>FIQ：高速中断，用于对延迟敏感的场景，优先级高于IRQ</p>
<ul>
<li>拥有<strong>独立的 R8–R14</strong>，可以快速响应，避免保存&#x2F;恢复通用寄存器</li>
</ul>
</li>
</ul>
<blockquote>
<p>GIC内部可以把中断标记成IRQ或FIQ再发给CPU，一般只有Secure World或高优先级中断用的是FIQ。Linux内核通常不使用FIQ模式，直接用IRQ模式处理</p>
</blockquote>
<ul>
<li><p>Abort：用于异常处理，比如访问非法地址或页错误</p>
<ul>
<li>发生内存访问异常时（Prefetch Abort &#x2F; Data Abort），CPU切换到该模式</li>
</ul>
</li>
<li><p>Undefined：未定义指令异常</p>
<ul>
<li>处理未定义指令时，CPU切换到该模式</li>
</ul>
</li>
<li><p>SVC：用于执行<strong>系统调用</strong></p>
<ul>
<li><p>CPU上电时进入的默认模式</p>
</li>
<li><p>由软件中断指令<code>SVC</code><strong>触发</strong></p>
</li>
</ul>
</li>
<li><p>System：用于<strong>内核线程</strong>的执行</p>
<ul>
<li>和 User 模式共享寄存器（R0–R12）</li>
<li>不会自动保存SPSR寄存器</li>
<li>不需要用<code>SVC</code>指令触发，当OS调度到一个内核线程时，进入该模式</li>
</ul>
</li>
</ul>
<h4 id="工作模式切换"><a href="#工作模式切换" class="headerlink" title="工作模式切换"></a>工作模式切换</h4><blockquote>
<p>CPU的工作模式（特权等级）主要通过以下方式&#x3D;&#x3D;切换&#x3D;&#x3D;：</p>
</blockquote>
<ul>
<li>中断&#x2F;异常：<ul>
<li>发生中断&#x2F;异常时，硬件自动切换到对应模式</li>
<li>中断&#x2F;异常返回时，恢复原模式</li>
</ul>
</li>
<li>软件触发：通过<code>SVC #imm</code> 汇编指令（<code>#imm</code> 是立即数，可用作系统调用编号），CPU自动切到SVC模式。类似RISCV的<code>ecall</code></li>
</ul>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><img src="../assets/image-20240904171832275.png" alt="image-20240904171832275"></p>
<blockquote>
<p>上面带三角的寄存器，在CPU不同的模式有不同的作用</p>
</blockquote>
<h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><blockquote>
<p>一共有13 + 5 + 7 + 7 +1 &#x3D; 33个</p>
</blockquote>
<p>R0~R15都属于通用寄存器，它们又可分为以下几类：</p>
<ul>
<li>R0–R12：普通寄存器，大部分模式共享，除了FIQ有专用的（R8~R12）<ul>
<li>未被用于特殊用途，一般就用来暂存数据、传递函数参数、返回值、返回地址等</li>
<li>发生函数跳转时，会造成此类寄存器数据的破坏，因此需要保存当前的数据到栈空间中，即&#x3D;&#x3D;保存上下文&#x3D;&#x3D;，实际上就是在进程的栈区里创建一个<strong>栈帧</strong>保存当前各个寄存器的值</li>
</ul>
</li>
<li>R13 (SP)：每种模式有独立的堆栈指针</li>
<li>R14 (LR)：相当于RISCV的<code>ra</code>，发生调转时，保存跳转前的<code>pc</code>. 每种模式有独立的链接寄存器</li>
<li>R15 (PC)：程序计数器，全局共享</li>
</ul>
<h4 id="程序状态寄存器"><a href="#程序状态寄存器" class="headerlink" title="程序状态寄存器"></a>程序状态寄存器</h4><blockquote>
<p>一共1 + 6 &#x3D; 7个</p>
</blockquote>
<ul>
<li>CPSR(Current Program Status Register)：<strong>当前</strong>程序状态寄存器</li>
</ul>
<p><img src="../assets/image-20240904195137643.png" alt="image-20240904195137643"></p>
<p>比较<strong>重要</strong>的功能有：</p>
<ul>
<li>中断的开关</li>
<li>工作模式的设置</li>
<li>指令模型</li>
</ul>
<hr>
<ul>
<li>SPSR(Saved Program Status Register)：备份的程序状态寄存器<ul>
<li>发生中断&#x2F;异常，会在目标模式的SPSR寄存器里备份CPSR的值</li>
<li>异常返回时，CPU用当前模式的目标模式SPSR 恢复CPSR</li>
<li>&#x3D;&#x3D;每个特权模式都有独立&#x3D;&#x3D;的SPSR寄存器，所以一共有6个（User无）</li>
</ul>
</li>
</ul>
<h4 id="系统控制寄存器"><a href="#系统控制寄存器" class="headerlink" title="系统控制寄存器"></a>系统控制寄存器</h4><table>
<thead>
<tr>
<th>寄存器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>SCTLR</td>
<td>系统控制寄存器，控制 MMU、Cache、分支预测等</td>
</tr>
<tr>
<td>TTBR0 &#x2F; TTBR1</td>
<td>页表基址寄存器（低地址 &#x2F; 高地址空间）</td>
</tr>
<tr>
<td>DACR</td>
<td>域访问控制寄存器，控制 domain 权限</td>
</tr>
<tr>
<td>DFSR &#x2F; IFSR</td>
<td>数据&#x2F;指令访问异常状态寄存器</td>
</tr>
<tr>
<td>DFAR &#x2F; IFAR</td>
<td>数据&#x2F;指令访问异常地址寄存器</td>
</tr>
<tr>
<td>CPACR</td>
<td>协处理器访问控制寄存器</td>
</tr>
<tr>
<td>其他</td>
<td>TLB、ASID、MPIDR 等多种辅助寄存器</td>
</tr>
</tbody></table>
<h4 id="协处理器寄存器"><a href="#协处理器寄存器" class="headerlink" title="协处理器寄存器"></a>协处理器寄存器</h4><ul>
<li>ARMv7-A支持协处理器（CP10&#x2F;CP11 常用于浮点单元或 NEON）</li>
<li>VFP &#x2F; NEON寄存器组：</li>
<li><ul>
<li>S0–S31（单精度浮点）</li>
<li>D0–D31（双精度浮点，S寄存器别名）</li>
</ul>
</li>
<li>通过VMRS &#x2F; VMSR &#x2F; VLDR &#x2F; VSTR指令访问</li>
</ul>
<h3 id="异常与中断"><a href="#异常与中断" class="headerlink" title="异常与中断"></a>异常与中断</h3><p>异常的概念：由CPU<strong>执行指令</strong>所导致的原来运行的程序的终止</p>
<h4 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h4><blockquote>
<p>不同的异常源会使CPU进入不同的工作模式</p>
</blockquote>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>CPU 模式</th>
<th>触发源（Source）</th>
<th>特征&#x2F;用途</th>
</tr>
</thead>
<tbody><tr>
<td>Reset</td>
<td>SVC &#x2F; Supervisor</td>
<td>上电或复位</td>
<td>初始化系统，CPU启动</td>
</tr>
<tr>
<td>Undefined Instruction</td>
<td>UND</td>
<td>执行未定义的指令</td>
<td>捕获非法指令异常</td>
</tr>
<tr>
<td>Software Interrupt (SVC指令)</td>
<td>SVC</td>
<td>执行 SVC 指令</td>
<td>用户程序请求系统调用</td>
</tr>
<tr>
<td>Prefetch Abort</td>
<td>ABT</td>
<td>指令预取错误（非法地址或权限）</td>
<td>内存访问异常</td>
</tr>
<tr>
<td>Data Abort</td>
<td>ABT</td>
<td>数据访问错误（非法地址或权限）</td>
<td>内存访问异常</td>
</tr>
<tr>
<td>IRQ</td>
<td>IRQ</td>
<td>外设普通中断</td>
<td>中断处理，一般优先级低</td>
</tr>
<tr>
<td>FIQ</td>
<td>FIQ</td>
<td>外设快速中断</td>
<td>高速中断，优先级高</td>
</tr>
</tbody></table>
<h4 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h4><p>1.异常发生：CPU 捕捉到异常源（IRQ、FIQ、SVC、Abort、Undefined、Reset 等）</p>
<p>2.中断屏蔽检查：</p>
<ul>
<li>如果是 IRQ&#x2F; FIQ：<ul>
<li>CPU 检查 CPSR.I &#x2F; CPSR.F 位 。如果屏蔽位已置位，则不响应该中断</li>
</ul>
</li>
</ul>
<p>3.CPU自动切换到对应的工作模式</p>
<p>4.硬件自动操作<strong>部分</strong>寄存器：</p>
<ul>
<li>将当前LR保存到对应工作模式的LR</li>
<li>将当前CPSR保存到对应工作模式的SPSR</li>
<li>交换当前SP和对应对应工作模式的SP</li>
<li>PC跳转到异常向量表对应的位置</li>
</ul>
<p><img src="../assets/image-20240905102604071.png" alt="image-20240905102604071"></p>
<p>5.执行异常处理程序：</p>
<ul>
<li><p>手动保存通用寄存器：将R0–R12<code>PUSH</code>到当前模式的栈</p>
</li>
<li><p>执行中断&#x2F;异常处理逻辑（具体实现与OS相关）：</p>
<ul>
<li><p>普通IRQ&#x2F;FIQ：读取外设中断号（GIC&#x2F;中断控制器寄存器），分发给对应ISR</p>
</li>
<li><p>SVC：根据<code>SVC #imm</code>中的立即数查系统调用表，调用内核服务</p>
</li>
<li><p>Abort（缺页&#x2F;存取异常）：</p>
<ul>
<li><p>访问系统控制寄存器：</p>
</li>
<li><p>DFSR&#x2F;IFSR（Fault Status Register）：错误类型</p>
</li>
<li><p>DFAR&#x2F;IFAR（Fault Address Register）：出错虚拟地址</p>
</li>
<li><p>内核根据异常类型决定修复（如加载缺页）还是杀死进程</p>
</li>
</ul>
</li>
<li><p>Undefined：通常触发内核信号，可能是非法指令</p>
</li>
</ul>
</li>
<li><p>可能需要的系统寄存器操作</p>
<ul>
<li>内存管理相关：切换TTBR0&#x2F;TTBR1（换页表）、失效TLB</li>
<li>Cache操作：清除&#x2F;失效Cache（通过CP15）</li>
<li>控制位修改：如修改SCTLR（开关MMU、Cache、对齐检查等）</li>
<li>异常信息获取：访问DFSR&#x2F;IFSR、DFAR&#x2F;IFAR</li>
</ul>
</li>
</ul>
<p>6.异常返回</p>
<ul>
<li>软件手动恢复通用寄存器R0~R12</li>
<li>执行返回指令，如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVS PC, SPSR_svc  ; 将 SPSR_svc 恢复到 CPSR，并跳回异常前的 PC</span><br></pre></td></tr></table></figure>

<ul>
<li>硬件自动恢复CPSR、PC、SP寄存器，恢复到User模式</li>
</ul>
<blockquote>
<p>一图流：</p>
</blockquote>
<img src="../assets/image-20240905104912888.png" alt="image-20240905104912888" style="zoom: 80%;" />

<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li>地址空间：ARMv7-A是32位的架构，所以最大4GB地址空间</li>
<li>MMU：由系统控制寄存器中的SCTLR.M来控制MMU的开关</li>
<li>页表：<ul>
<li>默认2级页表，由页表基址寄存器TTBR0和TTBR1存储页表基址</li>
<li>页表项定义了AP、XN等位进行权限的控制，定义了TEX、C、B等位来表示这块内存是普通内存还是外设的映射（PTE的内容原来是ISA定义的，不同的ISA还不一样）</li>
</ul>
</li>
<li>TLB：由专用的系统控制寄存器来控制，提供了刷新某页和全部TLB的指令</li>
<li>Cache：由专用的系统控制寄存器来控制，提供了失效所有Cache等指令</li>
<li>异常相关：当内存访问错误时，ARMv7-A会触发Abort异常，并把原因和出错地址保存到DFSR、IFSR等寄存器</li>
</ul>
<h2 id="ARMv7-M"><a href="#ARMv7-M" class="headerlink" title="ARMv7-M"></a>ARMv7-M</h2><h3 id="特权等级-1"><a href="#特权等级-1" class="headerlink" title="特权等级"></a>特权等级</h3><p>ARMv7M同样使用了两层分层模型（特权等级+处理器模式）来设计</p>
<p>具体地，包含2种工作模式，但是同一个工作模式可以示特权级别的，也可是非特权级别的：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Thread mode</th>
<th>Handler mode</th>
</tr>
</thead>
<tbody><tr>
<td>特权级</td>
<td>Privileged 或 Unprivileged</td>
<td>Privileged</td>
</tr>
<tr>
<td>栈指针</td>
<td>MSP或PSP（由CONTROL寄存器控制）</td>
<td>MSP</td>
</tr>
<tr>
<td>进入方式</td>
<td>复位、异常返回</td>
<td>异常&#x2F;中断</td>
</tr>
<tr>
<td>特权切换</td>
<td>可主动降级到Unprivileged</td>
<td>不可降级，永远特权</td>
</tr>
<tr>
<td>典型用途</td>
<td>RTOS线程</td>
<td>中断&#x2F;异常处理</td>
</tr>
</tbody></table>
<p>不同特权级别的区别：</p>
<ul>
<li><p>Privileged（特权级）</p>
<ul>
<li><p>可以访问所有指令和系统控制寄存器（例如 MPU、NVIC、SCB 等）</p>
</li>
<li><p>可以访问所有内存区域（除非 MPU 限制）</p>
</li>
<li><p>可以选择使用MSP或PSP作为栈指针</p>
</li>
</ul>
</li>
<li><p>Unprivileged（非特权级）</p>
<ul>
<li><p>被限制访问系统控制寄存器</p>
</li>
<li><p>内存访问受MPU限制</p>
</li>
<li><p>只能使用PSP作为栈指针</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>不同工作模式的区别：</p>
<ul>
<li><p>Thread mode</p>
<ul>
<li><p>异常处理程序之外的运行模式（比如用户应用或OS线程）</p>
</li>
<li><p>可以运行在特权级或非特权级</p>
</li>
<li><p>栈指针可以选择MSP或PSP（由 <code>CONTROL[1]</code> 决定）</p>
</li>
<li><p>系统复位时默认是该模式，且处于特权级，使用MSP</p>
</li>
<li><p>如果是裸机程序，就会一直在特权级+MSP下运行，但如果用RTOS，会把用户线程降级到非特权级+PSP，来进行隔离</p>
</li>
</ul>
</li>
<li><p>Handler mode</p>
<ul>
<li><p>处理异常&#x2F;中断时进入的模式</p>
</li>
<li><p>永远运行在特权级</p>
</li>
<li><p>栈指针固定使用MSP（不受CONTROL寄存器影响）</p>
</li>
<li><p>RTOS的任务调度器运行在特权级 + MSP下，因为任务调度是靠SysTick&#x2F;PendSV异常触发的</p>
</li>
</ul>
</li>
</ul>
<h4 id="工作模式的切换"><a href="#工作模式的切换" class="headerlink" title="工作模式的切换"></a>工作模式的切换</h4><table>
<thead>
<tr>
<th>场景</th>
<th>切换方式</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>Thread → Handler</td>
<td>发生异常&#x2F;中断</td>
<td>自动切换，Handler mode + Privileged + MSP</td>
</tr>
<tr>
<td>Handler → Thread</td>
<td>异常返回（EXC_RETURN）</td>
<td>自动切换回 Thread mode（PSP 或 MSP）</td>
</tr>
</tbody></table>
<h4 id="特权等级的切换"><a href="#特权等级的切换" class="headerlink" title="特权等级的切换"></a>特权等级的切换</h4><p>Thread mode 本身可以运行在不同的特权等级，可以通过CONTROL寄存器切换：</p>
<ul>
<li><code>CONTROL[0] = 0</code> → Privileged</li>
<li><code>CONTROL[0] = 1</code> → Unprivileged</li>
<li><code>CONTROL[1] = 0</code> → Thread 使用 MSP</li>
<li><code>CONTROL[1] = 1</code> → Thread 使用 PSP</li>
</ul>
<table>
<thead>
<tr>
<th>场景</th>
<th>切换方式</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>Thread (Privileged → Unprivileged)</td>
<td><code>MSR CONTROL, Rn</code></td>
<td>立即生效</td>
</tr>
<tr>
<td>Thread (Unprivileged → Privileged)</td>
<td>触发异常，再在 Handler 里改 CONTROL</td>
<td>通过异常回到特权级</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>从 Privileged → Unprivileged 可以直接改 CONTROL</li>
<li>从 Unprivileged → Privileged<strong>不行</strong>，只能通过触发异常（进入Handler mode），然后在异常处理程序里再改回去</li>
</ul>
<h3 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="通用寄存器-1"><a href="#通用寄存器-1" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>R0~R15都属于通用寄存器，它们又可分为以下几类：</p>
<ul>
<li>R0–R12：通用工作寄存器，用于参数传递、临时变量保存</li>
<li>R13 (SP)：栈指针，有MSP (Main SP)和 PSP (Process SP)两个实现，具体使用哪个由 <code>CONTROL[1]</code> 决定</li>
<li>R14 (LR)：相当于RISCV的<code>ra</code>，发生调转时，保存跳转前的<code>pc</code>. 每种模式有独立的链接寄存器</li>
<li>R15 (PC)：程序计数器，全局共享</li>
</ul>
<h4 id="程序状态寄存器-1"><a href="#程序状态寄存器-1" class="headerlink" title="程序状态寄存器"></a>程序状态寄存器</h4><p>xPSR (Program Status Register)，类似ARMv7-A的CPSR寄存器，但他做了精简，有以下字段：</p>
<ul>
<li>APSR (Application PSR)：条件码标志（N, Z, C, V, Q）</li>
<li>IPSR (Interrupt PSR)：当前异常号（0 &#x3D; Thread mode）</li>
<li>EPSR (Execution PSR)：包含 Thumb 状态位 T，IT 块状态</li>
</ul>
<h4 id="控制-配置寄存器"><a href="#控制-配置寄存器" class="headerlink" title="控制&#x2F;配置寄存器"></a>控制&#x2F;配置寄存器</h4><ul>
<li><p>CONTROL</p>
<ul>
<li>用于控制Thread mode下的<strong>特权级别</strong>和<strong>栈指针的</strong>选择，与Handler mode无关</li>
</ul>
</li>
<li><p>PRIMASK</p>
<ul>
<li><code>1 = 屏蔽所有可屏蔽异常</code>（除了 NMI 和 HardFault），<code>0 = 正常</code></li>
</ul>
</li>
<li><p>FAULTMASK</p>
<ul>
<li><p><code>1 = 屏蔽所有异常（包括 HardFault）</code>，仅 NMI 能打断</p>
</li>
<li><p>一般用于紧急临界区（比如出错恢复）</p>
</li>
</ul>
</li>
<li><p>BASEPRI</p>
<ul>
<li><p>存放一个优先级阈值</p>
</li>
<li><p>只允许比该值<strong>优先级更高</strong>的中断被响应</p>
</li>
<li><p>常用于 RTOS 的“临界区实现”</p>
</li>
</ul>
</li>
</ul>
<h4 id="异常相关寄存器"><a href="#异常相关寄存器" class="headerlink" title="异常相关寄存器"></a>异常相关寄存器</h4><p>在 System Control Block (SCB) 中，定义了一系列只读&#x2F;可写寄存器：</p>
<ul>
<li>ICSR (Interrupt Control and State Register)：显示当前异常号，支持触发 PendSV、SysTick 等</li>
<li>AIRCR (Application Interrupt and Reset Control Register)：系统复位、优先级分组配置</li>
<li>SCR (System Control Register)：睡眠模式控制</li>
<li>SHCSR (System Handler Control and State Register)：配置&#x2F;查询系统异常状态</li>
<li>CFSR (Configurable Fault Status Register)：详细错误状态（分为 MemManage&#x2F;Bus&#x2F;Usage Fault）</li>
<li>HFSR (HardFault Status Register)：HardFault 错误源</li>
<li>MMFAR&#x2F; BFAR：内存&#x2F;总线错误的出错地址</li>
</ul>
<h4 id="NVIC寄存器"><a href="#NVIC寄存器" class="headerlink" title="NVIC寄存器"></a>NVIC寄存器</h4><ul>
<li>ISER &#x2F; ICER：中断使能&#x2F;清除</li>
<li>ISPR &#x2F; ICPR：中断挂起&#x2F;清除</li>
<li>IPR：中断优先级设置</li>
</ul>
<h3 id="异常与中断-1"><a href="#异常与中断-1" class="headerlink" title="异常与中断"></a>异常与中断</h3><p>ARMv7-M 的异常总数最多496 个：</p>
<ul>
<li><p>前 16 个是系统异常（System Exceptions）（编号 1–15）</p>
</li>
<li><p>16 之后是外部中断（IRQ, Interrupt Requests），编号 16–(n-1)，由 NVIC 管理</p>
</li>
</ul>
<h4 id="异常类型-1"><a href="#异常类型-1" class="headerlink" title="异常类型"></a>异常类型</h4><p>1.系统异常（固定16个）</p>
<table>
<thead>
<tr>
<th>异常号</th>
<th>名称</th>
<th>优先级</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>15</td>
<td>Reset</td>
<td>固定最高</td>
<td>上电或复位时进入，取向量表中的 MSP 初值和 Reset Handler 地址</td>
</tr>
<tr>
<td>14</td>
<td>NMI (Non-Maskable Interrupt)</td>
<td>次高，仅次于 Reset</td>
<td>不可屏蔽，常用于紧急错误处理</td>
</tr>
<tr>
<td>13</td>
<td>HardFault</td>
<td>次高（仅次于 NMI）</td>
<td>严重错误（比如没有启用的 Fault 或执行错误）</td>
</tr>
<tr>
<td>12</td>
<td>MemManage Fault</td>
<td>可配置</td>
<td>内存保护单元（MPU）相关错误</td>
</tr>
<tr>
<td>11</td>
<td>BusFault</td>
<td>可配置</td>
<td>总线访问错误（如非法地址访问）</td>
</tr>
<tr>
<td>10</td>
<td>UsageFault</td>
<td>可配置</td>
<td>指令执行错误（未定义指令、除 0、未对齐访问等）</td>
</tr>
<tr>
<td>9-6</td>
<td>保留</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>SVCall (Supervisor Call)</td>
<td>可配置</td>
<td>通过 <code>SVC</code> 指令触发，常用于系统调用接口</td>
</tr>
<tr>
<td>4</td>
<td>Debug Monitor</td>
<td>可配置</td>
<td>调试相关异常</td>
</tr>
<tr>
<td>3</td>
<td>保留</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>PendSV (Pendable Service Call)</td>
<td>可配置</td>
<td>用于任务切换，RTOS 核心异常</td>
</tr>
<tr>
<td>1</td>
<td>SysTick</td>
<td>可配置</td>
<td>系统定时器中断，通常配合 RTOS 用于调度</td>
</tr>
</tbody></table>
<ul>
<li>PendSV：可挂起系统调用<ul>
<li>跟SVC很像，都是用于从用户态切换到内核态用的。但是相比于SVC的立即触发，PendSV<strong>延迟触发</strong>。通过<code>SCB-&gt;ICSR |= SCB_ICSR_PENDSVSET_Msk;</code>指令开启一个PendSV请求后，CPU会在<strong>空闲</strong>或<strong>当前中断完成</strong>后响应，并进入Hadler Mode，<strong>而不是立即响应</strong></li>
<li>&#x3D;&#x3D;引入目的&#x3D;&#x3D;：在RTOS中，任务的调度一般在SysTick中断中被触发，但是如果直接在SysTick中断中执行上下文切换的话，存在以下问题：<ul>
<li>高优先级中断的处理延迟：任务调度会消耗一定时间，如果在 SysTick中断中执行任务切换，系统可能无法及时处理其他高优先级中断，影响系统的响应性</li>
<li>实时性问题： 对于实时系统来说，任务切换在中断中执行可能会导致中断服务的执行时间增加，从而影响系统响应外部事件的能力</li>
</ul>
</li>
<li>为了解决这些问题，PendSV 引入了 延迟任务调度的机制，确保任务切换不会影响中断服务例程的执行。通过 PendSV，任务切换操作被 延迟到当前中断处理完成后 执行。具体流程：<ol>
<li>SysTick（或其他中断）触发任务调度：当 SysTick 定时器触发中断时，系统会标记需要进行任务切换。但任务切换不会立即在 SysTick ISR 中执行</li>
<li>PendSV 异常挂起：在 SysTick ISR 中，我们 设置 PendSV 异常挂起，而不是直接在 ISR 中执行任务调度。这样做的目的是把任务切换的操作 推迟到当前中断处理完成后，并确保高优先级中断不会被任务调度中断</li>
<li>PendSV 执行任切换：当当前中断处理完成后，系统会自动进入PendSV ISR，执行任务调度操作，并完成上下文切换</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>中断到线程的上下文切换可以用下图表示：</p>
<p><img src="....%5Cassets%5Cimage-20250830164804689.png" alt="image-20250830164804689"></p>
<ul>
<li>SVC<ul>
<li>通过<code>SVC #imm</code>指令可以触发一个软件中断，让CPU立即自动切换到Handler Mode，主要用于触发<strong>系统调用</strong>（内存分配、任务调度…）</li>
</ul>
</li>
</ul>
<p>2.外部中断 (IRQ)</p>
<ul>
<li>从异常号16 开始，每个外部中断对应NVIC 一个输入线</li>
<li>ARMv7-M 支持最多 240 个外设中断（具体数量取决于实现）</li>
<li>这些中断对应 SoC 外设（UART、SPI、I2C、GPIO、DMA …）</li>
</ul>
<p>优先级</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reset &gt; NMI &gt; HardFault &gt; 其他 Fault/系统异常 &gt; 外部中断</span><br></pre></td></tr></table></figure>

<h4 id="异常处理流程-1"><a href="#异常处理流程-1" class="headerlink" title="异常处理流程"></a>异常处理流程</h4><p>1.异常触发 </p>
<p>2.CPU自动切换工作模式和特权等级：切到Handler mode + Privileged</p>
<p>3.硬件自动操作部分寄存器：压R0–R3, R12, LR, PC, xPSR 到栈，切换SP为MSP</p>
<p>4.跳转到<strong>异常向量表</strong>中的异常入口</p>
<p>5.软件执行中断服务程序</p>
<p>6.执行<code>BX LR</code>进行异常返回，LR 中的<code>EXC_RETURN</code>字段决定返回到什么工作模式</p>
<p>STM32的异常向量表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__Vectors     DCD     __initial_sp             ; Top of Stack</span><br><span class="line">              DCD     Reset_Handler            ; Reset 处理函数</span><br><span class="line">              DCD     NMI_Handler              ; NMI 处理函数</span><br><span class="line">              DCD     HardFault_Handler        ; Hard Fault 处理函数</span><br><span class="line">              DCD     MemManage_Handler        ; MPU Fault 处理函数</span><br><span class="line">              DCD     BusFault_Handler         ; Bus Fault 处理函数</span><br><span class="line">              DCD     UsageFault_Handler       ; Usage Fault 处理函数</span><br><span class="line">              DCD     0                        ; 保留</span><br><span class="line">              DCD     0                        ; 保留</span><br><span class="line">              DCD     0                        ; 保留</span><br><span class="line">              DCD     0                        ; 保留</span><br><span class="line">              DCD     SVC_Handler              ; SVCall 处理函数</span><br><span class="line">              DCD     DebugMon_Handler         ; Debug Monitor 处理函数</span><br><span class="line">              DCD     0                        ; 保留</span><br><span class="line">              DCD     PendSV_Handler           ; PendSV 处理函数</span><br><span class="line">              DCD     SysTick_Handler          ; SysTick 处理函数</span><br></pre></td></tr></table></figure>

<p><code>__initial_sp</code>、<code>xxx_Handler</code>就是各个异常的处理函数，DCD是一个伪指令，但也能完成跳转</p>
<h3 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h3><p>ARMv7-M 并没有完全实现 MMU（内存管理单元） 和 虚拟内存。它依赖于 <strong>MPU（内存保护单元）</strong> 来管理内存访问权限，保障系统的稳定性和安全性</p>
<p>MPU 是一个硬件模块，&#x3D;&#x3D;用于对内存区域的访问进行权限控制&#x3D;&#x3D;。它的主要目的是提高系统的安全性和可靠性，防止任务对内存的非法访问</p>
<p>1.MPU 的工作原理：</p>
<ul>
<li><p>MPU 区域（Region）：MPU 可以配置多个内存区域。每个区域有一个 起始地址、大小 和 访问权限。</p>
</li>
<li><p>MPU 区域的权限控制：</p>
<ul>
<li>访问权限（AP, Access Permissions）：用于控制内存区域的访问权限，常见的权限包括：<ul>
<li>可读&#x2F;可写</li>
<li>只读</li>
<li>执行禁止（XN，Execute Never）</li>
</ul>
</li>
<li>特权级别：内存区域可以对 特权级（privileged）和 非特权级（unprivileged）的访问进行区分。</li>
</ul>
</li>
</ul>
<p>2.MPU 的作用：</p>
<ul>
<li>通过定义区域，可以限制任务访问某些特定内存区域，防止非法访问。</li>
<li>防止堆栈溢出或访问越界，保护任务堆栈和数据区。</li>
<li>在某些情况下，MPU 可以防止 代码注入 或 执行恶意代码，提高系统安全性。</li>
</ul>
<p>3.MPU 配置：</p>
<p>ARMv7-M 支持最多 8 个 MPU 区域，并通过控制寄存器进行配置。每个 MPU 区域由以下几个要素决定：</p>
<ul>
<li>起始地址</li>
<li>大小（通常是 32 字节、64 字节、128 字节、256 字节等的 2 的幂）</li>
<li>访问权限（读取、写入、执行等）</li>
<li>访问类型（如代码区域、数据区域等）</li>
</ul>
<p>MPU 配置的寄存器：</p>
<ul>
<li>MPU_CTRL：用于启用&#x2F;禁用 MPU。</li>
<li>MPU_RNR：选择当前操作的 MPU 区域。</li>
<li>MPU_RBAR：配置 MPU 区域的起始地址。</li>
<li>MPU_RASR：配置 MPU 区域的大小、权限、执行等设置。</li>
</ul>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>1.中断栈和任务栈有什么区别，保存在哪里</p>
<ul>
<li>在 Cortex-M 内核上，所有中断共享一个中断栈（MSP），进入中断时硬件会自动保存部分寄存器；而每个任务有独立的任务栈，由 RTOS 管理，用来保存任务上下文和函数调用现场。任务切换时，调度器会把寄存器现场压入任务栈，并在切回时恢复</li>
</ul>
<p>2.要实现任务调度，可以只有systick中断，不用pendsv吗？pendsv有什么优势</p>
<ul>
<li>可以的，正常流程是在Systick Handler发起一个PendSV请求然后在中断结束后进行真正地任务调度</li>
<li>不用PendSV的话就直接在Systick Handler内部进行任务切换，这会带来以下问题：<ul>
<li>增加中断的处理时间，影响实时性</li>
<li>如果某个任务自己触发了调度（比如调用 <code>taskYIELD()</code>），只能等下一个Systick到来时才能真正的切换</li>
</ul>
</li>
<li>PendSV的优势：<ul>
<li>调度逻辑和时钟中断解耦，SysTick 只管触发调度请求，PendSV 专心做切换，更加灵活和高效</li>
<li>优先级一般设的比较低，这样它不会打断真正的中断而造成影响</li>
<li>可以暂时挂起延迟执行，等高优先级的中断运行完了才运行</li>
<li>不依赖SysTick， <code>taskYIELD()</code>、信号量释放等情况，都可以设置PendSV的pending，从而触发调度</li>
</ul>
</li>
</ul>
<h2 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h2><h3 id="特权等级-2"><a href="#特权等级-2" class="headerlink" title="特权等级"></a>特权等级</h3><p>RISCV包含4个特权等级</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>编码</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>00</td>
<td>用户&#x2F;应用模式 (U, User&#x2F;Application)</td>
</tr>
<tr>
<td>1</td>
<td>01</td>
<td>监督模式 (S, Supervisor)</td>
</tr>
<tr>
<td>2</td>
<td>10</td>
<td>H, Hypervisor</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>机器模式 (M, Machine)</td>
</tr>
</tbody></table>
<p>RISC-V 架构中，只有 M 模式是必须实现的，剩下的特权级则可以根据跑在 CPU 上应用的实际需求进行调整：</p>
<ul>
<li>简单的嵌入式应用只需要实现 M 模式</li>
<li>带有一定保护能力的嵌入式系统(RTOS)需要实现 M&#x2F;U 模式</li>
<li>复杂的多任务系统(如Linux)则需要实现 M&#x2F;S&#x2F;U 模式</li>
<li>到目前为止，(Hypervisor, H)模式的特权规范还没完全制定好</li>
</ul>
<h3 id="寄存器-2"><a href="#寄存器-2" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="基础整数寄存器"><a href="#基础整数寄存器" class="headerlink" title="基础整数寄存器"></a>基础整数寄存器</h4><ul>
<li>RISC-V 基础指令集（RV32I&#x2F;RV64I）包含32个通用寄存器和一个PC指针，每个寄存器的大小和处理器的位宽相关，可能为32&#x2F;64&#x2F;128位</li>
<li>每个寄存器在编程时有特定的用途和别名，由ABI决定</li>
</ul>
<img src="..\..\assets\image-20250421162849924.png" alt="image-20250421162849924" style="zoom:80%;" />

<table>
<thead>
<tr>
<th align="center">寄存器</th>
<th align="center">ABI 名称</th>
<th align="center">用途</th>
<th align="center">是否调用保存</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>x0</code></td>
<td align="center"><code>zero</code></td>
<td align="center">硬编码为 0，写入无效，读取始终返回 0</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><code>x1</code></td>
<td align="center"><code>ra</code></td>
<td align="center">返回地址（Return Address），用于函数返回（如 <code>ret</code> 指令）</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"><code>x2</code></td>
<td align="center"><code>sp</code></td>
<td align="center">栈指针（Stack Pointer），指向当前栈顶</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><code>x3</code></td>
<td align="center"><code>gp</code></td>
<td align="center">全局指针（Global Pointer），用于访问全局数据（可选优化）</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><code>x4</code></td>
<td align="center"><code>tp</code></td>
<td align="center">线程指针（Thread Pointer），用于线程局部存储（TLS）</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><code>x5</code>-<code>x7</code></td>
<td align="center"><code>t0</code>-<code>t2</code></td>
<td align="center">临时寄存器，用于短期存储，函数调用后可能被覆盖</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"><code>x8</code></td>
<td align="center"><code>s0</code>&#x2F;<code>fp</code></td>
<td align="center">帧指针（Frame Pointer），用于调试或栈帧定位（可选）</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><code>x9</code></td>
<td align="center"><code>s1</code></td>
<td align="center">保存寄存器，函数调用后需恢复</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><code>x10</code>-<code>x11</code></td>
<td align="center"><code>a0</code>-<code>a1</code></td>
<td align="center">函数参数&#x2F;返回值，传递前两个参数或返回值</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"><code>x12</code>-<code>x17</code></td>
<td align="center"><code>a2</code>-<code>a7</code></td>
<td align="center">函数参数，传递第 3~8 个参数</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"><code>x18</code>-<code>x27</code></td>
<td align="center"><code>s2</code>-<code>s11</code></td>
<td align="center">保存寄存器，函数调用后需恢复</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><code>x28</code>-<code>x31</code></td>
<td align="center"><code>t3</code>-<code>t6</code></td>
<td align="center">临时寄存器，函数调用后可能被覆盖</td>
<td align="center">否</td>
</tr>
</tbody></table>
<ul>
<li>“是否调用保存”指的是，发送函数调用时，是否会保存该寄存器的值，还是直接覆盖</li>
</ul>
<h4 id="浮点寄存器"><a href="#浮点寄存器" class="headerlink" title="浮点寄存器"></a>浮点寄存器</h4><p>如果实现 <code>F</code> 或 <code>D</code> 扩展（单精度&#x2F;双精度浮点），RISC-V 提供<strong>32 个浮点寄存器</strong> <code>f0</code>-<code>f31</code>，位宽由扩展决定：</p>
<ul>
<li><code>F</code> 扩展：32 位（单精度）</li>
<li><code>D</code> 扩展：64 位（双精度）</li>
</ul>
<h4 id="状态控制寄存器"><a href="#状态控制寄存器" class="headerlink" title="状态控制寄存器"></a>状态控制寄存器</h4><ul>
<li><p>不同的特权级别分别对应<strong>各自</strong>的一套状态控制寄存器CSRs，用于配置和监控 CPU 状态（&#x3D;&#x3D;具体有哪些&#x3D;&#x3D;，请看RISC-V ISA手册Part2的Table 2.2）</p>
</li>
<li><p>高级别的特权级别下可以访问低级别的CSR， 譬如 Machine Level 下可以访问  Supervisor&#x2F;User Level 的 CSR，以此类推， 但反之不可以</p>
</li>
<li><p>RISC-V 定义了专门用于操作 CSR 的指令</p>
</li>
<li><p>RISC-V 定义了特定的指令可以用于在不同特权级别之间进行切换</p>
</li>
</ul>
<h3 id="异常与中断-2"><a href="#异常与中断-2" class="headerlink" title="异常与中断"></a>异常与中断</h3><h4 id="异常类型-2"><a href="#异常类型-2" class="headerlink" title="异常类型"></a>异常类型</h4><table>
<thead>
<tr>
<th align="center">异常代码</th>
<th align="center">助记符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">指令地址未对齐 (Instruction address misaligned)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">指令访问错误 (Instruction access fault)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">非法指令 (Illegal instruction)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">断点 (Breakpoint)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">加载地址未对齐 (Load address misaligned)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">5</td>
<td align="center">加载访问错误 (Load access fault)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">6</td>
<td align="center">存储&#x2F;原子操作地址未对齐 (Store&#x2F;AMO address misaligned)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">7</td>
<td align="center">存储&#x2F;原子操作访问错误 (Store&#x2F;AMO access fault)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">8</td>
<td align="center">用户模式系统调用 (Environment call from U-mode)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">9</td>
<td align="center">监管模式系统调用 (Environment call from S-mode)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">11</td>
<td align="center">机器模式系统调用 (Environment call from M-mode)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">12</td>
<td align="center">指令页错误 (Instruction page fault)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">13</td>
<td align="center">加载页错误 (Load page fault)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">15</td>
<td align="center">存储&#x2F;原子操作页错误 (Store&#x2F;AMO page fault)</td>
</tr>
</tbody></table>
<p><strong>相关寄存器</strong></p>
<ul>
<li>MODE：当前CPU的特权模式</li>
<li>SATP：当前MMU所使用页表的基址</li>
<li>STVEC：内核中处理Trap的指令的地址</li>
<li>SEPC：备份发生Trap时PC指针的值，结束时返回</li>
<li>SSCRATCH：临时存储数据，通常用于上下文保存时，切换用户&#x2F;内核栈，相当于一个cache</li>
<li>SCAUSE：保存了trap是什么类型（中断&#x2F;系统调用&#x2F;异常）</li>
<li>SSTATUS：中断使能控制；trap发生时的特权级保存；sret返回时的特权级设置</li>
<li>32个通用寄存器：作为上下文被保存</li>
</ul>
<blockquote>
<p>需要注意的是这些寄存器是S态的CSR寄存器。M态还有一套自己的CSR寄存器mcause，mtvec…</p>
</blockquote>
<h4 id="异常处理流程-2"><a href="#异常处理流程-2" class="headerlink" title="异常处理流程"></a>异常处理流程</h4><p>1.Trap 发生</p>
<ul>
<li>可能是 中断 (interrupt)：外部中断、定时器中断、软件中断</li>
<li>也可能是 异常 (exception)：非法指令、系统调用 (ECALL)、页错误、地址对齐错误等</li>
</ul>
<p>2.中断屏蔽检查</p>
<ul>
<li>先检查 mstatus 或 sstatus 里的中断使能位（如 MIE&#x2F;SIE）</li>
<li>检查 mie&#x2F;sie 寄存器的具体中断源使能</li>
<li>如果对应中断被屏蔽，则忽略</li>
</ul>
<p>3.模式切换</p>
<ul>
<li>如果启用了S，那么发生Trap时优先进入S Mode，否则直接进入M Mode</li>
</ul>
<p>4.硬件自动操作寄存器（CSR 自动更新）</p>
<ul>
<li>保存 PC：<ul>
<li>当前 PC → mepc &#x2F; sepc</li>
</ul>
</li>
<li>保存异常原因：<ul>
<li>Trap 原因号 → mcause &#x2F; scause</li>
<li>中断 vs 异常有标志位区分</li>
</ul>
</li>
<li>保存出错地址（如果有）：<ul>
<li>mtval &#x2F; stval ← 出错的虚拟地址 &#x2F; 指令字</li>
</ul>
</li>
<li>更新控制寄存器：<ul>
<li>mstatus：保存中断使能位 MIE 到 MPIE，并关闭中断</li>
<li>切换到异常目标模式（M 模式或 S 模式）</li>
</ul>
</li>
<li>PC 跳转：<ul>
<li>PC ← mtvec &#x2F; stvec（Trap 向量基址 + 偏移方式）</li>
</ul>
</li>
</ul>
<p>5.执行异常处理程序</p>
<ul>
<li>手动保存通用寄存器<ul>
<li>RISC-V 不会自动保存 x1–x31，软件必须把需要用的寄存器保存到栈里</li>
</ul>
</li>
<li>根据Trap类型执行逻辑<ul>
<li>中断：查询 mcause&#x2F;scause，确认是定时器中断、外部中断还是软件中断</li>
<li>ECALL（系统调用）：根据寄存器 a7（系统调用号）分发到内核服务</li>
<li>页错误（Page Fault）：读取 stval&#x2F;mtval 得到出错地址；OS 做缺页处理或杀进程</li>
<li>非法指令&#x2F;对齐错误：根据策略决定信号&#x2F;异常处理</li>
</ul>
</li>
<li>可选的 CSR 操作<ul>
<li>修改 satp（页表基址寄存器，切换地址空间）</li>
<li>清除&#x2F;设置 mip&#x2F;mie&#x2F;sip&#x2F;sie 中断位</li>
<li>可能会调整 mstatus&#x2F;sstatus</li>
</ul>
</li>
</ul>
<p>6.异常返回</p>
<ul>
<li>恢复之前保存的通用寄存器</li>
<li>执行异常返回指令：<ul>
<li>从 M 模式返回：<code>MRET</code></li>
<li>从 S 模式返回：<code>SRET</code></li>
</ul>
</li>
<li>硬件自动完成：<ul>
<li>PC ← mepc&#x2F;sepc（回到异常前指令）</li>
<li>mstatus&#x2F;sstatus 恢复中断使能（MPIE → MIE）</li>
<li>回到原模式（U&#x2F;S）继续执行</li>
</ul>
</li>
</ul>
<h3 id="内存管理-2"><a href="#内存管理-2" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li>地址空间：<ul>
<li>RISC-V 支持多种虚拟内存方案：<ul>
<li>Sv32（32 位虚拟地址，用于 RV32，最大 4GB）</li>
<li>Sv39（39 位虚拟地址，用于 RV64，最大 512GB）</li>
<li>Sv48（48 位虚拟地址，用于 RV64，最大 256TB）</li>
</ul>
</li>
<li>物理地址宽度由具体实现决定（通常 36~56 位）</li>
</ul>
</li>
<li>MMU：<ul>
<li>由 satp 寄存器控制，保存根页表基址和模式字段</li>
<li><code>satp.MODE=0</code> 时表示关闭 MMU（直接物理地址）</li>
</ul>
</li>
<li>页表：<ul>
<li>多级页表（Sv32 两级，Sv39&#x2F;Sv48 三级&#x2F;四级）</li>
<li>页表基地址由 satp.PPN 给出</li>
<li>页表项字段（ISA 定义）：<ul>
<li>V&#x2F;R&#x2F;W&#x2F;X&#x2F;U&#x2F;G&#x2F;A&#x2F;D 等位控制有效性、访问权限、执行权限、是否用户态可见、全局页、是否访问&#x2F;修改</li>
</ul>
</li>
<li>不同于 ARM，缓存&#x2F;内存属性不是在页表项里定义，而是通过 PMA&#x2F;PMP 来定义</li>
</ul>
</li>
<li>TLB：<ul>
<li>RISC-V 定义了 <code>SFENCE.VMA</code> 指令用于 TLB 刷新，没有像 ARM 那样的 CP15 接口，而是通过这条指令通知硬件失效部分或全部 TLB</li>
</ul>
</li>
<li>Cache：<ul>
<li>RISC-V 规范本身没有定义 Cache 控制指令</li>
<li>Cache 行失效&#x2F;清除等属于平台相关扩展（通常由实现或特权扩展提供）</li>
<li>ISA 层面只保证内存一致性模型（RVWMO）</li>
</ul>
</li>
<li>异常相关：<ul>
<li>发生内存访问错误时会触发 Page Fault 异常（Instruction &#x2F; Load &#x2F; Store Page Fault）</li>
<li>出错虚拟地址保存在 stval&#x2F;mtval寄存器，异常原因写入 scause&#x2F;mcause 寄存器</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://Li-Ruiqi777.github.io">Li Ruiqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://li-ruiqi777.github.io/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html">https://li-ruiqi777.github.io/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/06-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html" title="06 操作系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">06 操作系统</div></div><div class="info-2"><div class="info-item-1">操作系统内存管理1.超过一页的内存要怎么分配 2.内存碎片怎么处理 3.linux内存管理是怎么实现的，有了解吗 4.Linux是几级页表 5.怎么通过虚拟地址查找物理地址 6.零拷贝技术是什么 7.linux内核的物理内存管理方式（1）Buddy System（伙伴系统）​​  管理物理内存​​，按 2^n 页（4KB&#x2F;页）分配，避免碎片化 接口：alloc_pages(), __get_free_pages()  （2）Slab&#x2F;Slub&#x2F;Slob分配器​​  管理小块内存​​（如 task_struct），减少Buddy系统的内部碎片 接口：kmalloc(), kfree()  8.kmalloc最小内存分配，预期分配128字节实际多少？  kmalloc 最小分配单位：依赖Slab分配器的 size class，通常为 32字节或64字节（因架构而异） 分配128字节时的实际开销： 若Slab的 size class 包含128字节，则精确分配。 若无精确匹配，会向上取整到最近 size...</div></div></div></a><a class="pagination-related" href="/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html" title="03 计算机组成原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">03 计算机组成原理</div></div><div class="info-2"><div class="info-item-1">计算机组成原理参考链接 计算机组成原理 - 知乎  1.计算机的组成计算机通常包括以下几部分：  输入设备 输出设备 CPU：运算器 + 控制器 + 寄存器 + Cache + MMU + TLB… 总线：数据总线 + 地址总线 +...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Li Ruiqi</div><div class="author-info-description">总有低谷</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Li-Ruiqi777"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Li-Ruiqi777" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1009962019@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">计算机体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84vs%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">体系结构vs组成原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-SoC-MCU-MPU%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.2.</span> <span class="toc-text">CPU&#x2F;SoC&#x2F;MCU&#x2F;MPU的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARM%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">ARM授权模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">其他的一些概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">指令集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.2.</span> <span class="toc-text">机器指令、汇编、编程语言的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%B8%AD%E6%8C%87%E4%BB%A4%E5%92%8C%E4%BC%AA%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.3.</span> <span class="toc-text">汇编中指令和伪指令的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84-ISA"><span class="toc-number">1.3.</span> <span class="toc-text">指令集架构(ISA)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ISA%E7%9A%84%E5%AE%BD%E5%BA%A6"><span class="toc-number">1.3.2.</span> <span class="toc-text">ISA的宽度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">中断控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E5%86%85%E6%A0%B8-%E5%BE%AE%E6%9E%B6%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">CPU内核&#x2F;微架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARMv7-A"><span class="toc-number">1.6.</span> <span class="toc-text">ARMv7-A</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%9D%83%E7%AD%89%E7%BA%A7"><span class="toc-number">1.6.1.</span> <span class="toc-text">特权等级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">工作模式切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">程序状态寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">系统控制寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">协处理器寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="toc-number">1.6.3.</span> <span class="toc-text">异常与中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">异常类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">异常处理流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.4.</span> <span class="toc-text">内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARMv7-M"><span class="toc-number">1.7.</span> <span class="toc-text">ARMv7-M</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%9D%83%E7%AD%89%E7%BA%A7-1"><span class="toc-number">1.7.1.</span> <span class="toc-text">特权等级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">工作模式的切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%9D%83%E7%AD%89%E7%BA%A7%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">特权等级的切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-1"><span class="toc-number">1.7.2.</span> <span class="toc-text">寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8-1"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-1"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">程序状态寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6-%E9%85%8D%E7%BD%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">控制&#x2F;配置寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">异常相关寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NVIC%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.7.2.5.</span> <span class="toc-text">NVIC寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD-1"><span class="toc-number">1.7.3.</span> <span class="toc-text">异常与中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">异常类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-1"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">异常处理流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1"><span class="toc-number">1.7.4.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.7.5.</span> <span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RISC-V"><span class="toc-number">1.8.</span> <span class="toc-text">RISC-V</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%9D%83%E7%AD%89%E7%BA%A7-2"><span class="toc-number">1.8.1.</span> <span class="toc-text">特权等级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-2"><span class="toc-number">1.8.2.</span> <span class="toc-text">寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B4%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">基础整数寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">浮点寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">状态控制寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD-2"><span class="toc-number">1.8.3.</span> <span class="toc-text">异常与中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B-2"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">异常类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-2"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">异常处理流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-2"><span class="toc-number">1.8.4.</span> <span class="toc-text">内存管理</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Li Ruiqi</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">人因梦想而伟大</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
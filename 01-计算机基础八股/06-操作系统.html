<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>06 操作系统 | 李瑞琦的博客</title><meta name="author" content="Li Ruiqi"><meta name="copyright" content="Li Ruiqi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="操作系统内存管理1.超过一页的内存要怎么分配 2.内存碎片怎么处理 3.linux内存管理是怎么实现的，有了解吗 4.Linux是几级页表 5.怎么通过虚拟地址查找物理地址 6.零拷贝技术是什么 7.linux内核的物理内存管理方式（1）Buddy System（伙伴系统）​​  管理物理内存​​，按 2^n 页（4KB&#x2F;页）分配，避免碎片化 接口：alloc_pages(), __ge">
<meta property="og:type" content="article">
<meta property="og:title" content="06 操作系统">
<meta property="og:url" content="https://li-ruiqi777.github.io/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/06-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html">
<meta property="og:site_name" content="李瑞琦的博客">
<meta property="og:description" content="操作系统内存管理1.超过一页的内存要怎么分配 2.内存碎片怎么处理 3.linux内存管理是怎么实现的，有了解吗 4.Linux是几级页表 5.怎么通过虚拟地址查找物理地址 6.零拷贝技术是什么 7.linux内核的物理内存管理方式（1）Buddy System（伙伴系统）​​  管理物理内存​​，按 2^n 页（4KB&#x2F;页）分配，避免碎片化 接口：alloc_pages(), __ge">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://li-ruiqi777.github.io/img/head.png">
<meta property="article:published_time" content="2025-06-04T08:29:12.402Z">
<meta property="article:modified_time" content="2025-09-26T01:34:49.708Z">
<meta property="article:author" content="Li Ruiqi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://li-ruiqi777.github.io/img/head.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://li-ruiqi777.github.io/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/06-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '06 操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7.0/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/jetbrains-mono@4.5.12/index.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(135deg, #a9d6e0 0%, #e0f7fa 100%);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">19</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">李瑞琦的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">06 操作系统</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">06 操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-06-04T08:29:12.402Z" title="Created 2025-06-04 16:29:12">2025-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-09-26T01:34:49.708Z" title="Updated 2025-09-26 09:34:49">2025-09-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/">01-计算机基础八股</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>1.超过一页的内存要怎么分配</p>
<p>2.内存碎片怎么处理</p>
<p>3.linux内存管理是怎么实现的，有了解吗</p>
<p>4.Linux是几级页表</p>
<p>5.怎么通过虚拟地址查找物理地址</p>
<p>6.零拷贝技术是什么</p>
<p>7.linux内核的物理内存管理方式<br>（1）Buddy System（伙伴系统）​​</p>
<ul>
<li>管理物理内存​​，按 2^n 页（4KB&#x2F;页）分配，避免碎片化</li>
<li>接口：alloc_pages(), __get_free_pages()</li>
</ul>
<p>（2）Slab&#x2F;Slub&#x2F;Slob分配器​​</p>
<ul>
<li>管理小块内存​​（如 task_struct），减少Buddy系统的内部碎片</li>
<li>接口：kmalloc(), kfree()</li>
</ul>
<p>8.kmalloc最小内存分配，预期分配128字节实际多少？</p>
<ul>
<li><code>kmalloc</code> 最小分配单位：依赖Slab分配器的 <code>size class</code>，通常为 <strong>32字节或64字节</strong>（因架构而异）</li>
<li>分配128字节时的实际开销：<ul>
<li>若Slab的 <code>size class</code> 包含128字节，则精确分配。</li>
<li>若无精确匹配，会向上取整到最近 <code>size class</code>（如192字节）</li>
</ul>
</li>
<li>额外开销：<ul>
<li>内存对齐（通常8&#x2F;16字节对齐）</li>
<li>Slab元数据（如调试信息）</li>
</ul>
</li>
</ul>
<p>9.Linux下各个进程的虚拟内存空间的布局是什么样的？高端内存映射区是什么？它的地址是什么？</p>
<ul>
<li>首先Linux进程的虚拟内存空间分为内核空间和用户空间2部分</li>
</ul>
<p>10.为什么要有虚拟内存</p>
<ul>
<li>管理：它为每个进程提供独立的、连续的虚拟地址空间，让编译器和程序员无需关心物理内存的碎片化布局，简化了内存管理</li>
<li>保护：隔离了进程地址空间，并且使用页表权限控制机制，确保一个进程的错误或恶意行为不会影响其他进程和系统内核，提升了稳定性和安全性</li>
<li>扩展：通过交换技术，将磁盘空间作为内存的延伸，使得程序可以运行比物理内存更大的应用程序，实现了‘小内存跑大程序’</li>
<li>共享：允许将同一块物理内存（如库文件代码）映射到多个进程的地址空间，节省内存并提高效率</li>
</ul>
<p>11.什么是缺页异常，处理流程是什么</p>
<ul>
<li>见中断及异常管理那一章</li>
</ul>
<p>12.CPU访问内存的详细流程是什么</p>
<ul>
<li>CPU发出虚拟地址（VA）</li>
<li>MMU通过TLB快速将VA转换为PA（若TLB未命中，则查页表）</li>
<li>用PA访问Cache（若Cache未命中，则访问主存）</li>
<li>最终从Cache或主存读取数据返回CPU</li>
</ul>
<p>13.什么是内存交换技术</p>
<ul>
<li>物理内存紧张时，OS把某些进程的某些内存页的内容放到磁盘上，并释放这些内存页来获得一些可用的内存空间，当访问这些内存页时，再从磁盘把数据拿出来</li>
</ul>
<p>14.什么是内存屏障</p>
<ul>
<li>定义：内存屏障是一种特殊的指令或编译器指令，用来<strong>限制</strong> CPU 或编译器对内存访问的<strong>重排序</strong>，确保在多核&#x2F;多线程环境中内存访问的可见性和顺序性。分为编译器屏障和 CPU 硬件屏障，常见形式有读屏障、写屏障和全屏障</li>
<li>在 Linux 内核和驱动开发中，内存屏障常用于设备寄存器访问、多核同步、RCU 等场景，避免由于乱序执行导致的并发 bug</li>
</ul>
<p>15.什么是内存抖动</p>
<ul>
<li>定义：系统因为频繁的内存分配释放，或者频繁的页面换入换出，导致 CPU 大量时间花在内存管理上而不是执行真正任务，最终性能严重下降。</li>
<li>原因：<ul>
<li>在操作系统层面，它常见于物理内存不足引发的频繁 page fault，CPU一直忙于换页，应用跑不动</li>
<li>在应用层面，常见于频繁 malloc&#x2F;free 导致的内存碎片、Cache 命中率降低而导致性能下降</li>
</ul>
</li>
<li>解决方法一般有：增大物理内存、优化算法减少工作集、引入内存池避免频繁 malloc&#x2F;free</li>
</ul>
<p>16.<code>kmalloc</code>&#x2F;<code>vmalloc</code>的底层原理和区别是什么</p>
<p>17.缺页中断的原因是什么</p>
<ul>
<li>页面未分配：访问的虚拟地址没有对应的物理页</li>
<li>权限违规：比如写入只读页、用户空间访问内核空间</li>
<li>页面被置换到了磁盘中</li>
</ul>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>1.进程和线程的区别是什么</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">进程 (Process)</th>
<th align="left">线程 (Thread)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基本定义</td>
<td align="left">资源分配和拥有的基本单位</td>
<td align="left">程序执行的基本单位（CPU调度的基本单位）</td>
</tr>
<tr>
<td align="left">资源分配</td>
<td align="left">每个进程都有独立的地址空间、数据栈、代码段、文件句柄等系统资源。</td>
<td align="left">共享其所属进程的全部资源（如全局变量、堆、文件描述符）。拥有独立的栈和寄存器。</td>
</tr>
<tr>
<td align="left">通信方式</td>
<td align="left">IPC（进程间通信）：复杂度高，开销大。例如：管道、消息队列、共享内存、信号、套接字(Socket)。</td>
<td align="left">直接读写进程的全局数据：非常简单高效。但需要同步机制（如互斥锁、信号量）来避免竞态条件。</td>
</tr>
<tr>
<td align="left">创建与开销</td>
<td align="left">开销大。创建新进程（<code>fork()</code>）需要复制父进程的地址空间、文件描述符表等，是重量级操作。</td>
<td align="left">开销小。创建新线程（<code>pthread_create()</code>）只需分配独立的栈和寄存器，是轻量级操作。</td>
</tr>
<tr>
<td align="left">稳定性与隔离性</td>
<td align="left">隔离性高，更健壮。一个进程崩溃不会影响其他进程，因为它们的地址空间是独立的。</td>
<td align="left">隔离性低，稳定性差。一个线程崩溃（如非法内存访问）会导致整个进程及其所有其他线程一起崩溃。</td>
</tr>
<tr>
<td align="left">切换开销</td>
<td align="left">上下文切换开销大。需要切换页表、刷新TLB（快表）等。</td>
<td align="left">上下文切换开销小。只需切换寄存器、栈等，地址空间不变。</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">由于资源独立，并发编程更安全，但创建、通信、切换的成本更高。</td>
<td align="left">由于资源共享，通信和数据共享极其高效，极大地提升了程序的并发性能。</td>
</tr>
</tbody></table>
<p>2.PV操作是什么</p>
<p>3.无锁编程的方法</p>
<p>4.线程的同步和互斥怎么实现的</p>
<p>5.linux进程间通信方式有哪些？</p>
<table>
<thead>
<tr>
<th align="center">通信方式</th>
<th align="center">特点</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">管道（Pipe）</td>
<td align="center">单向通信，<strong>父子进程</strong>间使用（<code>int fd[2]; pipe(fd);</code>）</td>
<td align="center">命令行管道</td>
</tr>
<tr>
<td align="center">命名管道（FIFO）</td>
<td align="center">有文件名，<strong>无关进程</strong>可通过文件路径访问（<code>mkfifo</code>）</td>
<td align="center">持久化通信</td>
</tr>
<tr>
<td align="center">信号（Signal）</td>
<td align="center">异步通知（如 <code>SIGKILL</code>、<code>SIGUSR1</code>），信息量有限</td>
<td align="center">进程控制（如终止进程）</td>
</tr>
<tr>
<td align="center">共享内存</td>
<td align="center">最高效的方式，进程直接读写同一块内存（<code>shmget</code>&#x2F;<code>mmap</code>）</td>
<td align="center">高频数据交换（如视频处理）</td>
</tr>
<tr>
<td align="center">消息队列</td>
<td align="center">内核维护的链表，进程通过消息类型收发数据（<code>msgget</code>&#x2F;<code>msgsnd</code>&#x2F;<code>msgrcv</code>）</td>
<td align="center">结构化数据传输</td>
</tr>
<tr>
<td align="center">信号量</td>
<td align="center">同步工具，控制对共享资源的访问（<code>semget</code>&#x2F;<code>semop</code>）</td>
<td align="center">资源竞争管理（如数据库连接池）</td>
</tr>
<tr>
<td align="center">套接字</td>
<td align="center">跨网络或本机通信，支持TCP&#x2F;UDP（<code>socket()</code>&#x2F;<code>bind()</code>&#x2F;<code>listen()</code>）</td>
<td align="center">分布式系统或本地进程通信</td>
</tr>
<tr>
<td align="center">文件锁</td>
<td align="center">通过 <code>fcntl</code> 或 <code>flock</code> 对文件加锁</td>
<td align="center">协调文件访问（如日志写入）</td>
</tr>
</tbody></table>
<p>6.linux内核如何获取用户态进程pid？</p>
<p>对于一个进程，它处于用户态还是内核态，在内核眼里都是同一个<code>task_struct</code>，所以获取一个进程的pid跟它在用户态还是内核态无关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> pid = current-&gt;pid;  <span class="comment">// 通过该宏定义可以获取当前进程的PID</span></span><br></pre></td></tr></table></figure>

<p>7.linux内核空间和用户空间的通讯方式有哪些？</p>
<p>（1）系统调用（Syscall）</p>
<ul>
<li>最基础的方式，用户程序通过软中断（如 <code>int 0x80</code> 或 <code>syscall</code>）进入内核态</li>
<li>示例：<code>read()</code>, <code>write()</code>, <code>open()</code> 等</li>
</ul>
<p> （2）文件接口（&#x2F;proc, &#x2F;sysfs, &#x2F;dev）</p>
<ul>
<li>&#x2F;proc文件系统：内核暴露信息给用户空间（如 <code>/proc/cpuinfo</code>）</li>
<li>&#x2F;sysfs：用于设备驱动和内核对象管理（如 <code>/sys/class/net/eth0</code>）</li>
<li>设备文件（&#x2F;dev）：用户程序通过 <code>ioctl()</code> 与驱动交互（如 <code>/dev/mem</code>）</li>
</ul>
<p> （3）Netlink Socket</p>
<ul>
<li>面向网络的内核-用户通信，支持双向数据传输（如 <code>iproute2</code> 工具与内核网络子系统通信）</li>
<li>示例：<code>NETLINK_ROUTE</code>（网络配置）、<code>NETLINK_KOBJECT_UEVENT</code>（设备热插拔事件）</li>
</ul>
<p> （4）共享内存（mmap）</p>
<ul>
<li>用户空间通过 <code>mmap()</code> 映射内核内存（如 <code>DMA</code> 缓冲区），实现零拷贝高效通信</li>
<li>示例：显卡驱动、高速数据采集</li>
</ul>
<p> （5）信号（Signal）</p>
<ul>
<li>内核可向用户进程发送信号（如 <code>SIGKILL</code>、<code>SIGSEGV</code>），但信息量有限</li>
</ul>
<p> （6）BPF（eBPF）</p>
<ul>
<li>现代高性能内核-用户通信方式，允许用户空间向内核注入安全代码（如网络过滤、性能分析）</li>
</ul>
<p>8.死锁怎么产生，产生的几大条件，怎么解决</p>
<p>定义：死锁是指两个或多个并发进程&#x2F;线程在执行过程中，因<strong>争夺资源</strong>而陷入的一种<strong>相互等待</strong>的状态，若无外力干涉，它们都将无法继续推进</p>
<table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">描述</th>
<th align="left">通俗比喻</th>
</tr>
</thead>
<tbody><tr>
<td align="left">互斥</td>
<td align="left">资源一次只能被一个进程占用，其他进程如需访问必须等待</td>
<td align="left">独木桥一次只能过一个人</td>
</tr>
<tr>
<td align="left">占有并等待</td>
<td align="left">一个进程至少持有一个资源，并在等待获取其他进程持有的额外资源</td>
<td align="left">桥上的人（占有着桥的资源）在等对面的人让开（等待另一个资源）</td>
</tr>
<tr>
<td align="left">不可剥夺</td>
<td align="left">资源只能由持有它的进程自愿释放，不能被系统强制剥夺</td>
<td align="left">不能强行把桥上的人推下去</td>
</tr>
<tr>
<td align="left">循环等待</td>
<td align="left">存在一个进程等待序列 {P1, P2, …, Pn}，其中 P1 等待 P2 占有的资源，P2 等待 P3 占有的资源，…，Pn 等待 P1 占有的资源</td>
<td align="left">我等你，你等他，他等我，形成一个循环</td>
</tr>
</tbody></table>
<p>9.为什么说进程比线程开销大</p>
<p>10.<code>fork()</code>的作用是什么</p>
<ul>
<li>内核创建一个与父进程完全一样的子进程</li>
<li>内核会为子进程分配一个新的<code>task_struct</code>但是大多数字段会和父进程一样</li>
</ul>
<p>11.什么是Copy on Write Fork，哪些东西copy，哪些新建</p>
<ul>
<li>创建子进程时，子进程不会直接复制父进程的内存空间，而是创建一个新的page table后，复制父进程的所有PTE，并将父、子进程的所有PTE都标记为只读，之后对这些PTE写操作时，会触发page fault，重新分配物理页并更新PTE的权限</li>
<li>作用：减少创建新进程时的开销</li>
</ul>
<p>12.内核线程&#x2F;进程与用户线程&#x2F;进程有什么区别</p>
<ul>
<li>用户线程的page table同时包含用户空间和内核空间内存的映射，而内核线程的page table只有内核空间的映射</li>
<li>内核线程的<code>task_struct</code>中的内存描述符<code>mm</code>为NULL，<code>active_mm</code>指向上一个任务的<code>mm_struct</code></li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h4><p>Linux 支持多种调度策略，主要分为 实时调度 和 普通调度（Normal），不同调度策略的任务由不同调度器处理：</p>
<table>
<thead>
<tr>
<th align="center">调度策略</th>
<th align="center">说明</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>SCHED_DEADLINE</code></td>
<td align="center">实时调度，是按照 deadline 进行调度的，距离当前时间点最近的 deadline 的任务会被优先调度</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>SCHED_FIFO</code></td>
<td align="center">实时调度，优先级高的任务先执行，同优先级的按照先来先到的顺序运行，无时间片，直到主动让出或阻塞</td>
<td align="center">硬实时任务（如工业控制）</td>
</tr>
<tr>
<td align="center"><code>SCHED_RR</code></td>
<td align="center">实时调度，类似 <code>SCHED_FIFO</code>，但同优先级任务按时间片轮转</td>
<td align="center">需要公平性的实时任务</td>
</tr>
<tr>
<td align="center"><code>SCHED_NOARMAL</code></td>
<td align="center">普通调度（默认），基于 CFS 动态分配时间片</td>
<td align="center">普通进程（如桌面应用、后台服务）</td>
</tr>
<tr>
<td align="center"><code>SCHED_BATCH</code></td>
<td align="center">类似 <code>SCHED_OTHER</code>，但优化批处理任务（减少抢占）</td>
<td align="center">批处理任务（如编译）</td>
</tr>
<tr>
<td align="center"><code>SCHED_IDLE</code>（已废弃）</td>
<td align="center">最低优先级，仅在系统空闲时运行</td>
<td align="center">低优先级后台任务</td>
</tr>
</tbody></table>
<h4 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h4><p>Linux内核通过以下数据结构抽象出了调度器基类：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个调度器类（链表结构）</span></span><br><span class="line">    <span class="type">void</span> (*enqueue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">    <span class="type">void</span> (*dequeue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">    <span class="type">void</span> (*yield_task)   (<span class="keyword">struct</span> rq *rq);</span><br><span class="line">    <span class="type">void</span> (*check_preempt_curr)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *(*<span class="title">pick_next_task</span>)(<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="type">void</span> (*put_prev_task)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p);</span><br><span class="line">    <span class="comment">// ... 其他方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并实现了许多具体的调度器实例：</p>
<table>
<thead>
<tr>
<th align="center">调度器类</th>
<th align="center">管理的调度策略</th>
<th align="center">核心算法</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>rt_sched_class</code></td>
<td align="center"><code>SCHED_FIFO</code>, <code>SCHED_RR</code></td>
<td align="center">基于优先级的抢占式调度</td>
</tr>
<tr>
<td align="center"><code>fair_sched_class</code></td>
<td align="center"><code>SCHED_OTHER</code>, <code>SCHED_BATCH</code></td>
<td align="center">CFS（完全公平调度）</td>
</tr>
<tr>
<td align="center"><code>idle_sched_class</code></td>
<td align="center"><code>SCHED_IDLE</code></td>
<td align="center">仅在 CPU 空闲时运行</td>
</tr>
</tbody></table>
<img src="..\..\assets\image-20250831163008430.png" alt="image-20250831163008430" style="zoom:80%;" />

<h4 id="调度实体"><a href="#调度实体" class="headerlink" title="调度实体"></a>调度实体</h4><p>表示可被调度的对象，封装进程的调度信息（如 <code>vruntime</code>、权重等），供调度类使用。一般是<code>task_struct</code>的&#x3D;&#x3D;成员变量&#x3D;&#x3D;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>    <span class="title">load</span>;</span>       <span class="comment">// 权重（优先级相关）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>        <span class="title">run_node</span>;</span>   <span class="comment">// 在CFS红黑树中的节点</span></span><br><span class="line">    u64                   vruntime;   <span class="comment">// CFS虚拟运行时间</span></span><br><span class="line">    <span class="comment">// 其他字段（如组调度、统计信息等）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span>  <span class="comment">// 普通进程的调度实体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span> <span class="comment">// 实时进程的调度实体（若为实时任务）</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="运行队列"><a href="#运行队列" class="headerlink" title="运行队列"></a>运行队列</h4><p>每个CPU核心都维护了自己的运行队列存放<code>task_struct</code>实例），调度时，首先根据调度器的优先级选择对应的调度器，然后从他的任务队列选择一个进行切换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> <span class="title">cfs</span>;</span>       <span class="comment">// CFS运行队列（存储普通进程）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> <span class="title">rt</span>;</span>        <span class="comment">// 实时运行队列（存储实时进程）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span>;</span> <span class="comment">// 当前正在运行的进程</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="主调度器"><a href="#主调度器" class="headerlink" title="主调度器"></a>主调度器</h4><p>是整个调度流程的统称，他其实是个函数<code>schedule()</code>，触发时机包括：</p>
<ul>
<li>时间片耗尽（定时器中断）</li>
<li>进程阻塞或主动让出CPU（如sys_sched_yield）</li>
<li>高优先级任务就绪（如实时任务唤醒）</li>
</ul>
<h3 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h3><p>先看一下内核中有哪些数据结构以及他们是如何分布的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 1. 基础调度策略 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>                policy;         <span class="comment">// 调度策略（SCHED_NORMAL=0, SCHED_FIFO=1, SCHED_RR=2, ...）</span></span><br><span class="line">    <span class="type">int</span>                         static_prio;    <span class="comment">// 静态优先级（映射到 nice 值，范围 100~139，对应 nice -20~19）</span></span><br><span class="line">    <span class="type">int</span>                         prio;           <span class="comment">// 动态优先级（可能因优先级继承或互斥锁提升）</span></span><br><span class="line">    <span class="type">int</span>                         normal_prio;    <span class="comment">// 基于静态优先级和调度策略计算的标准优先级</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>                rt_priority;    <span class="comment">// 实时优先级（1~99，仅对 SCHED_FIFO/SCHED_RR 有效）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 调度器类关联 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span>    *<span class="title">sched_class</span>;</span>   <span class="comment">// 指向当前调度器类（fair_sched_class, rt_sched_class 等）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>         <span class="title">se</span>;</span>             <span class="comment">// CFS 调度实体（用于 SCHED_NORMAL/SCHED_BATCH）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span>      <span class="title">rt</span>;</span>             <span class="comment">// 实时调度实体（用于 SCHED_FIFO/SCHED_RR）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span>      <span class="title">dl</span>;</span>             <span class="comment">// Deadline 调度实体（用于 SCHED_DEADLINE）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 调度统计与状态 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>                sched_flags;    <span class="comment">// 调度标志（如 SCHED_FLAG_DL_OVERRUN）</span></span><br><span class="line">    u64                         vruntime;       <span class="comment">// CFS 虚拟运行时间（纳秒级，在 sched_entity 内）</span></span><br><span class="line">    u64                         exec_start;     <span class="comment">// 当前调度周期开始时间</span></span><br><span class="line">    u64                         sum_exec_runtime; <span class="comment">// 累计实际运行时间</span></span><br><span class="line">    <span class="comment">// ... 其他字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Linux的具体调度流程如下，其实非常简单，就是选择下一个任务然后切换上下文：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/core.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">    prev = current;  <span class="comment">// 当前任务</span></span><br><span class="line">    next = pick_next_task(rq);  <span class="comment">// 选择下一个任务</span></span><br><span class="line">    context_switch(rq, prev, next);  <span class="comment">// 切换上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较核心的函数是选择下一个任务，在该函数中，会依次遍历所有<strong>调度器的运行队列</strong>，来选择下一个任务到底是什么</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sched/core.c</span></span><br><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">pick_next_task</span><span class="params">(<span class="keyword">struct</span> rq *rq)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历调度器类（从最高优先级开始）</span></span><br><span class="line">    for_each_class(class) &#123;</span><br><span class="line">        p = class-&gt;pick_next_task(rq);</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="keyword">return</span> p;  <span class="comment">// 找到可运行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 无任务可运行（运行 idle 任务）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相关系统调用"><a href="#相关系统调用" class="headerlink" title="相关系统调用"></a>相关系统调用</h3><p><img src="....%5Cassets%5Cimage-20250813110954596.png" alt="image-20250813110954596"></p>
<h3 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h3><p>1.进程调度有哪些方法</p>
<p>2.中断会引起线程的调度吗</p>
<p>3.什么时候会引起线程的调度</p>
<p>在 Linux 内核中，任务调度（进程调度）主要发生在以下时机，这些时机可以归纳为<strong>主动调度</strong>和<strong>被动调度</strong>两类：</p>
<ul>
<li><p>主动调度：进程主动放弃 CPU，触发调度器选择下一个任务：</p>
<ul>
<li><p>系统调用中显式调用 <code>schedule()</code>：比如进程调用 <code>sleep()</code>、<code>nanosleep()</code>、<code>sched_yield()</code> 等函数时，会主动让出 CPU</p>
</li>
<li><p>阻塞操作：当进程等待资源（如文件 I&#x2F;O、网络数据、信号量、锁等）时，会进入阻塞状态，内核会主动调用 <code>schedule()</code> 切换其他任务</p>
</li>
<li><p><code>cond_resched()</code> 检查：在内核代码的某些长时间循环中（如文件系统或网络栈），会调用 <code>cond_resched()</code> 检查是否需要调度，避免长时间占用 CPU</p>
</li>
</ul>
</li>
<li><p>被动调度（抢占式调度）内核强制剥夺当前任务的 CPU 使用权：</p>
<ul>
<li><p>时间片耗尽：在 <code>CFS</code>中，当在定时器中断中发现进程的时间片用完时，调度器会被触发</p>
</li>
<li><p>中断返回时：硬件中断或系统调用返回用户空间前，内核会检查 <code>TIF_NEED_RESCHED</code> 标志位。若被标记，则调用 <code>schedule()</code> 切换任务</p>
</li>
<li><p>更高优先级任务就绪，例如：</p>
<ul>
<li>实时进程（RT 任务）被唤醒</li>
<li>使用 <code>wake_up_process()</code> 唤醒的进程优先级高于当前进程</li>
</ul>
</li>
<li><p>内核抢占（Kernel Preemption）配置了 <code>CONFIG_PREEMPT</code>时，内核态任务也可能被抢占：</p>
<ul>
<li>在中断处理返回内核态时（非关键路径）</li>
<li>显式调用 <code>preempt_enable()</code> 时检查抢占标志</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>4.抢占式进程调度要怎么实现</p>
<p>5.介绍下CFS调度算法</p>
<ul>
<li>完全公平调度算法的核心思想是让每个任务的运行时间基本一致，他给每个任务维护了一个虚拟运行时间<code>vruntime</code>变量，当做这个任务的运行时间，当CFS调度器选择下一个运行的任务时，会选择<code>vruntime</code>的任务运行。<code>vruntime</code>并不是实际运行时间，而是结合任务的优先级、nice值和实际的运行时间计算的到的，优先级越大，相同实际运行时间对应的<code>vruntime</code>越低</li>
</ul>
<p>7.CFS底层怎么实现的，用的什么数据结构，红黑树怎么取的，key和value是什么</p>
<p>8.介绍下Linux的进程调度模块</p>
<ul>
<li>Linux内核调度机制的核心目标是公平高效地分配CPU资源，同时支持实时任务。它采用多级调度架构实现进程调度，主要组件包括主调度器（Core Scheduler）、调度类（Scheduling Classes）和运行队列（Runqueue），通过策略（如CFS、实时调度）和事件驱动（如中断、系统调用）实现动态调度</li>
</ul>
<h2 id="驱动开发"><a href="#驱动开发" class="headerlink" title="驱动开发"></a>驱动开发</h2><h3 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h3><p>1.设备树的作用是什么</p>
<ul>
<li>描述板级信息，把硬件的详细信息从驱动中抽离出来，增加驱动的复用性</li>
</ul>
<p>2.设备树和驱动<strong>匹配</strong>的详细流程</p>
<ul>
<li>设备树和驱动的匹配本质上是设备和驱动在同一条总线上通过<code>bus_type</code>的<code>match()</code>回调函数找到彼此，流程分为以下几步：<ul>
<li>设备树的硬件描述：首先设备树中使用<code>compatible</code>等属性对设备进行标识</li>
<li>内核解析并创建设备对象：内核启动时，会解析DTB文件，将各个节点转换成<code>struct device_node</code>。并且根据所在总线类型（I2C、SPI、platform），转换成对应的 <code>device</code> 对象，例如 <code>i2c_client</code> 或 <code>platform_device</code>，并存到对应总线维护的链表</li>
<li>驱动注册并匹配：每次有新驱动注册到内核时，都会触发总线的<code>match</code>函数，遍历设备链表看看有没有和该驱动匹配的，如果有的话，就会调用驱动的<code>probe</code>函数</li>
<li>probe阶段：完成设备的初始化，比如向内核申请GPIO、中断等资源、注册字符设备…</li>
</ul>
</li>
</ul>
<p>3.probe函数触发条件</p>
<ul>
<li><code>probe</code>函数其实是<code>bus_type</code>的一个回调函数，当bus通过<code>match</code>成功匹配驱动和设备时，会调用该函数</li>
</ul>
<p>4.设备和驱动匹配的方法有哪些</p>
<ul>
<li>设备树方式：节点的<code>compatible</code>属性和驱动的<code>.of_matchtable</code>字段一致</li>
<li>ACPI方式：x86架构常用</li>
<li><code>id_table</code>：驱动的<code>.id_table</code>字段和设备对象里的名字(比如<code>i2c_client-&gt;name</code>)进行匹配</li>
<li>名字方式：设备的 <code>name</code>（来自设备树节点名字里@前的部分）和驱动的 <code>driver.name</code> 一致</li>
</ul>
<p>5.内核<strong>解析</strong>设备树节点的详细流程（父节点、子节点、address-cells&#x2F;size-cells）</p>
<ul>
<li>设备树传递：Bootloader将DTB加载到RAM，并在启动内核时把地址传给内核</li>
<li>内核早期解包：在内核启动初期（汇编阶段），会调用<code>early_init_dt_scan()</code>对DTB进行初步验证，读取其Magic Number，并获取一个指向根节点的全局指针</li>
<li>在内核中构建设备树数据结构：之后内核会调用<code>unflatten_device_tree()</code>在内核中构建设备树，将设备树节点转化为<code>struct device_node</code>，每个属性对应<code>struct property</code></li>
<li>解析设备树的chosen&#x2F;memory节点：<ul>
<li>解析 <code>chosen</code> 节点里的 <code>bootargs</code>（内核启动参数）</li>
<li>解析 <code>memory</code> 节点里的物理内存大小和起始地址</li>
</ul>
</li>
<li>总线扫描并注册设备：当各个 bus（platform、i2c、spi、pci）初始化时，会调用相应的 <code>of_xxx_populate()</code>去扫描设备树下的子节点，把<code>device_node</code>转成设备对象并挂到总线上<ul>
<li>platform 总线：<code>of_platform_populate()</code> → <code>of_platform_device_create_pdata()</code> → 创建 <code>platform_device</code></li>
<li>i2c 总线：<code>of_i2c_register_devices()</code> → 创建 <code>i2c_client</code></li>
<li>spi 总线：<code>of_register_spi_devices()</code> → 创建 <code>spi_device</code></li>
</ul>
</li>
<li>匹配和probe：当驱动注册时（或设备先注册时），总线<code>match</code>函数会拿<code>device-&gt;of_node-&gt;compatible</code> 对比 <code>driver-&gt;of_match_table</code>。如果匹配成功则会调用 <code>probe()</code></li>
</ul>
<p>6.内核<strong>加载</strong>DTB文件的详细流程</p>
<ul>
<li>Bootloader 阶段：选定并加载 dtb 文件到内存，启动内核时把 dtb 地址通过寄存器传给内核</li>
<li>内核启动早期：在 <code>setup_arch()</code> 中获取 dtb 地址，调用 <code>early_init_dt_verify()</code> 校验合法性，并在必要时 relocate</li>
<li>DTB 解析阶段：<code>early_init_dt_scan_nodes()</code> 解析 <code>/chosen</code> 和 <code>/memory</code>，随后 <code>of_flat_dt_scan()</code> 遍历整个 dtb，构建 <code>struct device_node</code> 树，并处理父子关系、<code>#address-cells</code> &#x2F; <code>#size-cells</code> 等信息。</li>
<li>后续使用：平台代码和总线框架（platform、I2C、SPI 等）再根据这些 <code>device_node</code> 实例化出具体的 <code>device</code>，等待驱动匹配</li>
</ul>
<p>7.对于先有设备后有驱动以及先有驱动后有设备，内核分别是怎么创建设备节点的</p>
<ul>
<li>先有设备：device节点是由设备树解析产生 → 进入 device 链表，等 driver 上来再匹配</li>
<li>先有驱动：driver先挂到driver链表，等device节点被创建（热插拔&#x2F;DT late add&#x2F;硬件枚举等）再触发匹配</li>
</ul>
<p>8.设备树里面主要的一些属性以及作用</p>
<ul>
<li>看之前的笔记，挺多的</li>
</ul>
<p>9.一个驱动里面需要哪些设备树信息</p>
<ul>
<li>不同的设备不一样啊，至少得有用于和驱动匹配的一些属性比如<code>compatible</code></li>
</ul>
<p>10.说一下gpio驱动怎么写</p>
<ul>
<li>比如下面这个，需要GPIO控制器，这个pin在该控制器下的索引，有效电平</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">led-gpio = &lt;&amp;gpio1 3 GPIO_ACTIVE_LOW&gt;;</span><br></pre></td></tr></table></figure>



<h3 id="驱动框架"><a href="#驱动框架" class="headerlink" title="驱动框架"></a>驱动框架</h3><p>1.<code>struct file_operations</code>有哪些操作函数</p>
<ul>
<li>open&#x2F;close&#x2F;read&#x2F;write&#x2F;unlocked_ioctl&#x2F;mmap…</li>
</ul>
<p>2.字符设备驱动的注册流程是怎样的 &#x2F; 如何写个字符设备的驱动</p>
<ul>
<li>向内核申请一个主设备号（静态指定或者内核动态分配）</li>
<li>初始化一个<code>struct cdev</code>，主要是填充<code>ops</code>和<code>owner</code>字段</li>
<li>使用<code>cdev_add</code>添加cedv到内核</li>
<li>创建设备节点文件（<code>class_create()</code>，<code>device_create()</code>）</li>
</ul>
<p>3.主&#x2F;次设备号的范围和作用</p>
<ul>
<li>主设备号：驱动类别，12位</li>
<li>次设备号：同一驱动下的不同设备实例，20位</li>
</ul>
<p>4.应用层的<code>open/read/write/ioctl</code> 是如何对应到驱动层函数的 &#x2F; 调用流程</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/linux/imx6/driver/zh/latest/linux_driver/character_device.html">字符设备驱动 — 野火嵌入式Linux驱动开发实战指南——基于i.MX6ULL系列 文档</a>：看4.5</p>
<ul>
<li>应用层的 <code>open/read/write/ioctl</code> 实际上是glibc的库函数，内部会发起系统调用，执行<code>SVC</code>&#x2F;<code>ecall</code>之类的特权指令，触发异常</li>
<li>用户空间使用<code>open()</code>系统调用函数打开一个字符设备时(int fd &#x3D; open(“dev&#x2F;xxx”, O_RDWR))大致有以下过程：<ul>
<li>内核在虚拟文件系统VFS中的查找对应与字符设备路径对应<code>inode</code>对象，获得主设备号</li>
<li>遍历内核中的cdev_map<strong>哈希表</strong>，根据inod节点中的主设备号找到cdev对象</li>
<li>创建并初始化<code>struct file</code>对象，将 struct file对象中的 file_operations成员指向 struct cdev对象中的 file_operations成员（file-&gt;fops &#x3D; cdev-&gt;fops）</li>
<li>回调file-&gt;fops-&gt;open函数</li>
<li>返回内核中新创建的<code>file</code>对象在内核中的索引即fd</li>
</ul>
</li>
</ul>
<p>5.驱动里如何实现阻塞式 <code>read</code>？（比如等待按键按下才返回）</p>
<p>6.知道platform总线设备驱动的特点和核心思想吗</p>
<ul>
<li>platform设备驱动框架的核心思想是实现通过提出一种虚拟总线，所有的驱动开发都可以遵循”设备-驱动-总线“这种模型，实现驱动和设备的解耦。让Linux的驱动开发统一化，增加了驱动的可移植性</li>
</ul>
<h3 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h3><p>1.为什么有了驱动注册的代码前面要加<code>__init</code>和<code>__exit</code>宏？</p>
<ul>
<li><code>__init</code>宏定义会把被修饰的函数放到ELF文件的<code>.init.text</code>节区，内核启动的时候，会通过<code>init_call</code>机制自动执行该段的所有函数，并在执行完毕后释放内存</li>
</ul>
<p>2.驱动的加载流程是什么</p>
<ul>
<li>驱动可以直接编译进内核（静态加载），也可以编译成一个内核模块（动态加载），2者的加载流程是有很大区别的：</li>
<li>静态加载<ul>
<li>驱动中通过<code>module_init()</code>宏将驱动的初始化函数放到一个特定的内存节区（例如<code>.initcall</code>）</li>
<li>内核启动时，利用initcall机制，按特定顺序依次执行所有这些初始化函数</li>
</ul>
</li>
<li>动态加载<ul>
<li>用户空间调用<code>insmod</code>或<code>modprobe</code>命令，在命令中通过<code>sys_init_module()</code>系统调用陷入内核</li>
<li>内核首先检查当前用户的权限并分配内存，然后将<code>.ko</code>文件的内容拷贝到内核，并解析ELF文件</li>
<li>内核调用模块通过 <code>module_init()</code>宏注册的初始化函数</li>
</ul>
</li>
</ul>
<p>3.用户空间是如何在<code>/dev</code>目录下创建设备节点的</p>
<ul>
<li><code>/dev</code> 下的设备节点本质上是一个特殊文件，包含主次设备号，用来让用户空间访问内核驱动</li>
<li>早期是通过 <code>mknod</code> 手动创建</li>
<li>现代系统通常由 <code>udev</code>&#x2F;<code>mdev</code> 自动完成：驱动里调用 <code>class_create</code> 和 <code>device_create</code> 在 sysfs 里生成设备信息，<code>udev</code>守护进程监听到内核uevent热插拔事件后，自动在 <code>/dev</code> 下生成对应的设备节点</li>
</ul>
<h3 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h3><p>1.V4L2会向应用层提供设备节点，比如<code>/dev/video0</code>，假如有多个进程要同时需要<code>/dev/video0</code>的数据，该怎么处理</p>
<ul>
<li>独占模式：驱动中维护一个变量表示当前设备的打开状态，当设备被一个进程打开后，其他进程<code>open</code>时返回错误</li>
<li>多句柄共享模式：每个进程都在内核创建自己的buffer queue，然后通过mmap映射</li>
<li>用户空间共享：只有一个进程负责读取数据，通过进程间的通信机制比如共享内存传递给其他进程</li>
<li>使用 <code>v4l2loopback</code> 创建虚拟设备，把同一份数据复制到多个虚拟节点，让多个进程各自打开</li>
</ul>
<p>2.对于普通的字符设备，如果有多个进程操作，如何处理</p>
<ul>
<li><p>独占访问</p>
<ul>
<li>驱动在 <code>open()</code> 里检查是否已经被占用，如果是则返回 <code>-EBUSY</code>。常见于硬件资源有限</li>
</ul>
</li>
<li><p>多进程共享读写</p>
<ul>
<li><p>驱动内部做并发控制，例如加锁（spinlock&#x2F;mutex），保证多进程同时访问时不会破坏硬件或数据</p>
</li>
<li><p>例如串口驱动，允许多个进程 <code>read()</code>&#x2F;<code>write()</code>，驱动里会维护接收缓冲区和发送缓冲区</p>
</li>
</ul>
</li>
<li><p>一个生产者、多消费者</p>
<ul>
<li><p>驱动可以设计一个 环形缓冲区，把硬件数据放进去，然后多个进程 <code>read()</code> 时各自消费</p>
</li>
<li><p>或者像 input 子系统（键盘、触摸屏），内核本身提供 多播机制，保证每个进程都能收到事件</p>
</li>
</ul>
</li>
<li><p>用户空间转发</p>
<ul>
<li>如果驱动本身不支持多进程共享，可以像 V4L2 一样，在用户态做转发：一个进程独占设备，再用共享内存&#x2F;Socket&#x2F;管道把数据分发给其他进程</li>
</ul>
</li>
</ul>
<h2 id="中断及异常管理"><a href="#中断及异常管理" class="headerlink" title="中断及异常管理"></a>中断及异常管理</h2><p>1.外部中断的实现原理</p>
<p>2.中断的概念</p>
<ul>
<li>CPU在执行当前代码的时候被打断，转而去执行另一端代码（ISR）</li>
</ul>
<p>3.用什么函数注册中断</p>
<p>4.在中断中要注意什么</p>
<ul>
<li>中断上下文中，不能睡眠</li>
</ul>
<p>5.中断和异常有什么区别</p>
<ul>
<li>中断是CPU指令以外的事件引起的</li>
<li>异常是由CPU指令引起的</li>
</ul>
<p>6.多个中断同时发生怎么办</p>
<ul>
<li><p>控制器会根据中断优先级决定哪一个先送给 CPU</p>
</li>
<li><p>其他中断被标记为挂起</p>
</li>
<li><p>CPU 响应当前优先级最高的中断后，控制器会继续把下一个挂起中断送到 CPU</p>
</li>
</ul>
<p>7.中断上下文里面用什么方式实现资源共享</p>
<p>在中断上下文访问共享资源时，不能使用会睡眠的锁（如 mutex）常用方式有：</p>
<ul>
<li><p>spinlock（多核 CPU，可加 <code>irqsave</code> 禁中断）</p>
</li>
<li><p>local_irq_disable &#x2F; irq_save（单核 CPU 临界区）</p>
</li>
<li><p>atomic 原子操作（简单计数器或标志）</p>
</li>
<li><p>RCU &#x2F; seqlock（读多写少数据结构</p>
</li>
</ul>
<p>选择合适的方式可以保证 ISR 与底半部以及进程上下文安全地共享资源</p>
<p>8.上半部和下半部使用场景 &#x2F; 为什么Linux的中断要分为上下半部</p>
<ul>
<li><p>降低中断延迟</p>
<ul>
<li><p>硬件中断会屏蔽同级或低级中断，如果 ISR 里做的事情太多，会延迟其他中断的响应</p>
</li>
<li><p>分上下半部后，上半部硬中断上下文，执行快，只做关键的最小操作</p>
</li>
</ul>
</li>
<li><p>允许复杂操作</p>
<ul>
<li>硬中断上下文不能休眠（例如不能调用 <code>schedule()</code>、不能拿可能阻塞的锁），所以像内存分配、文件操作等都必须放到下半部</li>
</ul>
</li>
<li><p>提高系统吞吐量</p>
<ul>
<li>上半部快速返回，系统能及时响应更多硬件中断；下半部可以批量处理数据，减少频繁的中断开销</li>
</ul>
</li>
</ul>
<p>9.page fault处理流程是什么</p>
<p>下面以ARMv7A为例：</p>
<ul>
<li><p>CPU访问一个page table中没有有效映射（PTE）的虚拟地址</p>
</li>
<li><p>MMU触发Data Abort异常，并分别保存出错的地址和原因到FAR和FSR寄存器</p>
</li>
<li><p>PC跳转到异常向量表中的Data Abort或Prefetch Abort入口，并进入内核的异常处理函数中</p>
</li>
<li><p>在内核的<code>do_page_fault()</code>中进行缺页异常的核心处理流程</p>
<ul>
<li><p>首先检查地址是否合法：通过 <code>find_vma(mm, addr)</code> 在当前进程的内存描述符（ <code>mm_struct</code>）中看是否能找到对应的VMA</p>
<ul>
<li><p>找不到：访问非法地址，给当前进程发SIGSEGV</p>
</li>
<li><p>找到了但权限不匹配：给当前进程发SIGSEGV</p>
</li>
<li><p>如果合法且权限匹配，则进入后续的步骤</p>
</li>
</ul>
</li>
<li><p>缺页处理：区分匿名页缺页 和 文件映射缺页</p>
<ul>
<li>匿名页（堆、栈）：分配新的物理页 → 建立页表映射</li>
<li>文件映射：触发 page cache 读入</li>
</ul>
</li>
<li><p>更新page table，刷新TLB</p>
</li>
</ul>
</li>
<li><p>返回用户态，继续执行</p>
</li>
</ul>
<p>10.什么是中断上下文</p>
<ul>
<li>当CPU响应一个硬件中断时，内核所执行的中断处理程序（ISR）的运行环境</li>
</ul>
<p>11.为什么中断上下文中不能进行阻塞&#x2F;睡眠</p>
<ul>
<li>中断上下文不是一个进程，它没有属于自己的、可以被保存和恢复的任务结构（<code>task_sturct</code>），因此一旦阻塞（睡眠），就再也没有办法被唤醒并继续执行了</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="面试问题-1"><a href="#面试问题-1" class="headerlink" title="面试问题"></a>面试问题</h3><p>1.用户进程调用<code>read()</code>来读一个块设备中的文件内容到用户空间中，具体发生了什么？</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>1.为什么中断中不能睡眠</p>
<ul>
<li>中断上下文无法保存：中断没有自己的<code>task_struct</code>，如果睡眠则会发生任务调度，无法从其他任务再切换回中断</li>
<li>破坏实时性：中断要求快速响应，睡眠会导致不可预测的延迟</li>
</ul>
<p>2.堆和栈的区别是什么</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">堆（Heap）</th>
<th align="center">栈（Stack）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">管理方式</td>
<td align="center">手动申请&#x2F;释放（<code>malloc/free</code>）</td>
<td align="center">自动分配&#x2F;释放（函数调用时）</td>
</tr>
<tr>
<td align="center">连续性</td>
<td align="center">动态增长，地址不连续（碎片化）</td>
<td align="center">连续内存，大小固定（可能溢出）</td>
</tr>
<tr>
<td align="center">速度</td>
<td align="center">慢（需系统调用和复杂管理）</td>
<td align="center">快（仅移动栈指针）</td>
</tr>
<tr>
<td align="center">作用域</td>
<td align="center">全局可见，需手动释放</td>
<td align="center">局部变量，函数退出自动销毁</td>
</tr>
<tr>
<td align="center">典型问题</td>
<td align="center">内存泄漏、碎片化</td>
<td align="center">栈溢出（如递归过深）</td>
</tr>
</tbody></table>
<p>3.进程的上下文具体指什么</p>
<ul>
<li>从硬件的角度看：CPU中的各个寄存器（PC、SP、MMU基址）</li>
<li>从软件的角度看：<ul>
<li>虚拟地址空间</li>
<li>打开的文件</li>
<li>PCB</li>
</ul>
</li>
</ul>
<p>4.锁的类型有哪些</p>
<table>
<thead>
<tr>
<th align="center">锁类型</th>
<th align="center">特点</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">自旋锁</td>
<td align="center">忙等待（不睡眠），适用于短临界区</td>
<td align="center">多核、中断上下文</td>
</tr>
<tr>
<td align="center">睡眠锁</td>
<td align="center">睡眠等待，避免CPU浪费</td>
<td align="center">长临界区、进程上下文</td>
</tr>
<tr>
<td align="center">读写锁</td>
<td align="center">允许多读&#x2F;单写，提高并发性</td>
<td align="center">读多写少（如配置文件）</td>
</tr>
</tbody></table>
<p>5.系统调用用户态到内核态会发生什么</p>
<p>6.用户态堆栈在系统调用时会发生什么变化吗</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">用户态栈</th>
<th align="center">用户态堆</th>
</tr>
</thead>
<tbody><tr>
<td align="center">系统调用时是否变化</td>
<td align="center">不变，syscall时会切换至内核栈</td>
<td align="center">一般不变，除非显式调用 <code>brk</code>&#x2F;<code>mmap</code></td>
</tr>
<tr>
<td align="center">内核访问方式</td>
<td align="center">完全隔离（内核用独立栈）</td>
<td align="center">可通过安全接口（如 <code>copy_from_user</code>）访问</td>
</tr>
</tbody></table>
<p>7.什么是用户态、什么是内核态</p>
<p>程序运行在用户空间就是用户态，运行在内核空间就是内核态。</p>
<ul>
<li>从硬件角度来看，用户态CPU处于低特权等级，只能操作部分寄存器，不能访问硬件。而内核态CPU处于高特权等级，可以操作所有寄存器并访问硬件</li>
<li>从出错危害性来看，用户态如果一个程序崩溃了，不会影响别的程序，而内核态崩溃了，可能OS就崩溃了，只能重启系统</li>
</ul>
<p>8.FreeRTOS和Linux的主要区别是什么</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">FreeRTOS</th>
<th align="left">Linux</th>
</tr>
</thead>
<tbody><tr>
<td align="left">本质与目标</td>
<td align="left">实时操作系统（RTOS） 核心目标是<strong>确定性</strong>和<strong>实时性</strong>，保证任务在严格的时间限制内完成</td>
<td align="left">通用操作系统（GPOS） 核心目标是<strong>吞吐量</strong>和<strong>公平性</strong>，公平地为所有应用程序分配资源</td>
</tr>
<tr>
<td align="left">内核架构</td>
<td align="left">微内核（Microkernel） 内核只提供最核心的功能（任务调度、IPC、内存管理），其他功能（如网络栈、文件系统）作为可选组件在用户任务中实现</td>
<td align="left">宏内核（Monolithic Kernel） 内核庞大而完整，将文件系统、网络协议栈、设备驱动等大量功能都集成在内核空间中，性能高但复杂度也高</td>
</tr>
<tr>
<td align="left">应用场景</td>
<td align="left">深度嵌入式、实时控制领域 航空航天、工业自动化、医疗器械、汽车电子（如ECU）、家电、IoT设备等运行在资源极度受限的微控制器（MCU）上，如STM32，ESP32，Cortex-M系列</td>
<td align="left">应用处理器、复杂系统 服务器、桌面电脑、智能手机、路由器、智能电视、功能复杂的嵌入式设备（如机器人、自动驾驶域控制器）运行在资源丰富的微处理器（MPU）上，如Cortex-A系列，x86</td>
</tr>
<tr>
<td align="left">硬件资源需求</td>
<td align="left">极低 ROM: 几KB ~ 几十KB RAM: 几百字节即可运行，通常几KB~几十KB CPU: 无MMU要求，8位、16位、32位MCU均可</td>
<td align="left">很高 ROM: 至少几MB（精简版），通常几十MB到数GB RAM: 至少几MB（精简版），通常上百MB到数GB CPU: 通常需要带MMU（内存管理单元）的MPU</td>
</tr>
<tr>
<td align="left">调度策略</td>
<td align="left">优先级抢占式调度，支持时间片轮转。高优先级任务就绪时，会立即抢占低优先级任务响应时间是微秒（µs）级，确定性极高（硬实时）</td>
<td align="left">完全公平调度（CFS）等，旨在让所有进程公平地分享CPU时间，优化整体系统吞吐量响应时间是毫秒（ms）级，虽然可以通过打PREEMPT-RT补丁提升实时性，但本质仍是软实时</td>
</tr>
<tr>
<td align="left">内存管理</td>
<td align="left">简单 通常只提供简单的堆内存分配（<code>pvPortMalloc</code> &#x2F; <code>vPortFree</code>），开发者需要根据芯片RAM大小自行配置，<strong>无虚拟内存</strong>，直接访问物理地址</td>
<td align="left">复杂且安全 使用虚拟内存管理，每个进程都有独立的、受保护的地址空间。这提高了系统的稳定性和安全性，一个进程崩溃不会导致整个系统崩溃</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://Li-Ruiqi777.github.io">Li Ruiqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://li-ruiqi777.github.io/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/06-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html">https://li-ruiqi777.github.io/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/06-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/05-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html" title="05 计算机网络"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">05 计算机网络</div></div><div class="info-2"><div class="info-item-1">计算机网络网络体系结构对于网络体系结构的划分，主要有2种形式： OSI七层网络模型 看赛博二哈的八股（第115条）  OSI（Open Systems Interconnection）模型由ISO提出，是一个理论分层框架，用于标准化网络通信过程。虽然实际网络并未完全采用OSI，但它对理解网络协议分层至关重要    层数 名称 功能 协议&#x2F;设备示例 关键词    7 应用层 提供用户接口，实现具体应用功能（如文件传输、邮件收发） HTTP、FTP、SMTP、DNS    6 表示层 数据格式转换（加密、压缩、编码） SSL&#x2F;TLS、JPEG、ASCII    5 会话层 建立、管理、终止应用程序间的会话 NetBIOS、RPC    4 传输层 提供端到端的数据传输（流量控制、错误恢复） TCP、UDP 端口号、TCP、 UDP   3 网络层 实现主机间的逻辑寻址和路由选择，跨越不同网络 IP、ICMP、路由器 IP地址、路由 器、ping通   2 数据链路层 将比特流封装成数据帧（使用MAC地址在网卡间通信） ARP、网卡、交换机、...</div></div></div></a><a class="pagination-related" href="/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/02-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html" title="02 计算机体系结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">02 计算机体系结构</div></div><div class="info-2"><div class="info-item-1">计算机体系结构基本概念体系结构vs组成原理 体系结构：能被程序员看到的计算机系统的属性，即概念性的结构和功能特性（主要是被汇编程序员所看到的属性，包括指令集、数据类型、存储器寻址技术、IO机理等…）  示例：  冯诺依曼架构  哈佛架构  核心内容：  多核协同：一致性协议（如 MESI）、互联总线（如 AMBA ACE）  内存子系统：NUMA 支持、内存控制器设计  外设与扩展：PCIe、USB 控制器、加速器（如 NPU）的集成  安全与虚拟化：TrustZone、IOMMU、虚拟化扩展（如 ARM SMMU）        组成原理：指如何实现计算机体系结构所体现的属性，它包含了很多对程序员来说是透明的硬件细节。比如规定一台计算机有哪些属性属于体系结构的问题，但如何通过电路实现这些指令，属于组成原理的问题      对比维度 体系结构 组成原理    关注点 软件可见的属性 硬件如何实现这些属性   面向对象 程序员 &#x2F;...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Li Ruiqi</div><div class="author-info-description">总有低谷</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Li-Ruiqi777"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Li-Ruiqi777" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1009962019@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">进程管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">调度策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">调度器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%AE%9E%E4%BD%93"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">调度实体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">运行队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">主调度器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E8%B0%83%E5%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">Linux调度的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">相关系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.4.</span> <span class="toc-text">面试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="toc-number">1.4.</span> <span class="toc-text">驱动开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-number">1.4.1.</span> <span class="toc-text">设备树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">驱动框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.4.3.</span> <span class="toc-text">内核模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-number">1.4.4.</span> <span class="toc-text">场景题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%8F%8A%E5%BC%82%E5%B8%B8%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">中断及异常管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.6.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">面试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-number">1.7.</span> <span class="toc-text">杂项</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Li Ruiqi</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">人因梦想而伟大</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
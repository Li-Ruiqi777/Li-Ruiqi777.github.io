<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>XV6 | 李瑞琦的博客</title><meta name="author" content="Li Ruiqi"><meta name="copyright" content="Li Ruiqi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="XV61.调试1.首先在一个终端里通过make qemu-gdb启动gdbserver 2.配置vscode的lauch.json，包括gdb路径、输入参数之类的 3.使用vscode开始调试 2.RISC-V ISAISA应该包含以下内容：  指令集 寄存器集 内存模型 异常与中断处理机制 特权级别 …(不同ISA包含的东西不一样)  参考链接 ch02-riscv-isa-introducti">
<meta property="og:type" content="article">
<meta property="og:title" content="XV6">
<meta property="og:url" content="https://li-ruiqi777.github.io/07-RISC-V/XV6.html">
<meta property="og:site_name" content="李瑞琦的博客">
<meta property="og:description" content="XV61.调试1.首先在一个终端里通过make qemu-gdb启动gdbserver 2.配置vscode的lauch.json，包括gdb路径、输入参数之类的 3.使用vscode开始调试 2.RISC-V ISAISA应该包含以下内容：  指令集 寄存器集 内存模型 异常与中断处理机制 特权级别 …(不同ISA包含的东西不一样)  参考链接 ch02-riscv-isa-introducti">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://li-ruiqi777.github.io/img/head.png">
<meta property="article:published_time" content="2025-06-04T08:29:12.730Z">
<meta property="article:modified_time" content="2025-06-04T08:29:38.781Z">
<meta property="article:author" content="Li Ruiqi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://li-ruiqi777.github.io/img/head.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://li-ruiqi777.github.io/07-RISC-V/XV6.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'XV6',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7.0/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/jetbrains-mono@4.5.12/index.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(135deg, #a9d6e0 0%, #e0f7fa 100%);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">143</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">19</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">李瑞琦的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">XV6</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">XV6</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-06-04T08:29:12.730Z" title="Created 2025-06-04 16:29:12">2025-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-06-04T08:29:38.781Z" title="Updated 2025-06-04 16:29:38">2025-06-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/07-RISC-V/">07-RISC-V</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="XV6"><a href="#XV6" class="headerlink" title="XV6"></a>XV6</h1><h2 id="1-调试"><a href="#1-调试" class="headerlink" title="1.调试"></a>1.调试</h2><p>1.首先在一个终端里通过<code>make qemu-gdb</code>启动gdbserver</p>
<p>2.配置vscode的<code>lauch.json</code>，包括gdb路径、输入参数之类的</p>
<p>3.使用vscode开始调试</p>
<h2 id="2-RISC-V-ISA"><a href="#2-RISC-V-ISA" class="headerlink" title="2.RISC-V ISA"></a>2.RISC-V ISA</h2><p>ISA应该包含以下内容：</p>
<ul>
<li>指令集</li>
<li>寄存器集</li>
<li>内存模型</li>
<li>异常与中断处理机制</li>
<li>特权级别</li>
<li>…(不同ISA包含的东西不一样)</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="C:/Users/lrq/Desktop/嵌入式秋招/01-参考项目/riscv-operating-system-mooc/slides/ch02-riscv-isa-introduction.pdf">ch02-riscv-isa-introduction.pdf</a></li>
<li><a href="C:/Users/lrq/Desktop/嵌入式秋招/01-参考项目/riscv-operating-system-mooc/slides/ch05-assemble-programming.pdf">ch05-assemble-programming.pdf</a></li>
<li><a href="C:/Users/lrq/Desktop/嵌入式秋招/01-参考项目/riscv-operating-system-mooc/slides/ch10-trap-exception.pdf">ch10-trap-exception.pdf</a></li>
<li><a href="C:/Users/lrq/Desktop/嵌入式秋招/01-参考项目/riscv-operating-system-mooc/refs/RISC-V-Reader-Chinese-v2p1.pdf">RISC-V-中文参考手册</a></li>
<li><a href="C:/Users/lrq/Desktop/嵌入式秋招/01-参考项目/riscv-operating-system-mooc/refs/riscv-privileged-20190608-1.pdf">RISC-V ISA手册Part2 : 特权级别相关</a></li>
<li><a target="_blank" rel="noopener" href="https://learningos.cn/uCore-Tutorial-Guide-2024S/chapter2/1rv-privilege.html">特权级机制 - uCore-Tutorial-Guide-2024S 文档</a></li>
</ul>
<h3 id="特权等级"><a href="#特权等级" class="headerlink" title="特权等级"></a>特权等级</h3><p>RISCV包含4个特权等级</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>编码</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>00</td>
<td>用户&#x2F;应用模式 (U, User&#x2F;Application)</td>
</tr>
<tr>
<td>1</td>
<td>01</td>
<td>监督模式 (S, Supervisor)</td>
</tr>
<tr>
<td>2</td>
<td>10</td>
<td>H, Hypervisor</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>机器模式 (M, Machine)</td>
</tr>
</tbody></table>
<p>RISC-V 架构中，只有 M 模式是必须实现的，剩下的特权级则可以根据跑在 CPU 上应用的实际需求进行调整：</p>
<ul>
<li>简单的嵌入式应用只需要实现 M 模式</li>
<li>带有一定保护能力的嵌入式系统(RTOS)需要实现 M&#x2F;U 模式</li>
<li>复杂的多任务系统(如Linux)则需要实现 M&#x2F;S&#x2F;U 模式</li>
<li>到目前为止，(Hypervisor, H)模式的特权规范还没完全制定好</li>
</ul>
<p><strong>不同特权等级的区别是什么？</strong></p>
<ul>
<li>高特权等级相对于U-mode，只是多了一些指令和寄存器、能访问更多的PTE，除此之外没啥区别</li>
<li>只有S-Mode能控制MMU的页表基址(<code>satp</code>)</li>
</ul>
<h3 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h3><p>RISC-V的基础整数指令集(I)主要包含以下几类指令：</p>
<ul>
<li>整数寄存器操作：算数运算、逻辑运算</li>
<li>控制流指令：无条件跳转、条件分支</li>
<li>内存访问指令：寄存器存储到内存(<code>sd</code>)、内存加载到寄存器(<code>ld</code>)</li>
<li>内存屏障指令：<code>fence</code>等</li>
<li>系统调用&#x2F;断点：<code>ecall</code>、<code>ebreak</code></li>
<li>CSR操作指令：对CSR寄存器进行读写</li>
<li>伪指令：空操作、<code>mv</code>….</li>
</ul>
<p>RV32I&#x2F;RV64I <strong>不包含</strong>以下功能（需通过扩展模块实现）：</p>
<ul>
<li>乘除法：需 <code>M</code> 扩展（指令如 <code>MUL</code>、<code>DIV</code>）</li>
<li>原子操作：需 <code>A</code> 扩展（如 <code>LR</code>&#x2F;<code>SC</code>、<code>AMO</code>）</li>
<li>浮点运算：需 <code>F</code>（单精度）&#x2F;<code>D</code>（双精度）扩展</li>
<li>压缩指令：需 <code>C</code> 扩展（16 位指令编码）</li>
</ul>
<h4 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h4><p><code>ecall</code>：</p>
<p>(1)将CPU从用户模式切换到SVC模式</p>
<p>(2)保存当前的PC到SEPC寄存器</p>
<p>(3)将PC指针跳转到STVEC寄存器指向的指令 </p>
<blockquote>
<p>RISC-V的<code>ecall</code>的设计原则是使其尽可能的简单，所以不会切换页表，也不会保存上下文，这些都要靠软件实现</p>
</blockquote>
<p><code>sret</code>：</p>
<p>(1)特权等级切换：将CPU从SVC模式切换到用户模式</p>
<p>(2)从<code>sepc</code>恢复<code>pc</code>的值</p>
<p>(2)重新开启中断</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="基础整数寄存器"><a href="#基础整数寄存器" class="headerlink" title="基础整数寄存器"></a>基础整数寄存器</h4><ul>
<li>RISC-V 基础指令集（RV32I&#x2F;RV64I）包含32个通用寄存器和一个PC指针，每个寄存器的大小和处理器的位宽相关，可能为32&#x2F;64&#x2F;128位</li>
<li>每个寄存器在编程时有特定的用途和别名，由ABI决定</li>
</ul>
<img src="../assets/image-20250421162849924.png" alt="image-20250421162849924" style="zoom:80%;" />

<table>
<thead>
<tr>
<th align="center">寄存器</th>
<th align="center">ABI 名称</th>
<th align="center">用途</th>
<th align="center">是否调用保存</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>x0</code></td>
<td align="center"><code>zero</code></td>
<td align="center">硬编码为 0，写入无效，读取始终返回 0</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><code>x1</code></td>
<td align="center"><code>ra</code></td>
<td align="center">返回地址（Return Address），用于函数返回（如 <code>ret</code> 指令）</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"><code>x2</code></td>
<td align="center"><code>sp</code></td>
<td align="center">栈指针（Stack Pointer），指向当前栈顶</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><code>x3</code></td>
<td align="center"><code>gp</code></td>
<td align="center">全局指针（Global Pointer），用于访问全局数据（可选优化）</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><code>x4</code></td>
<td align="center"><code>tp</code></td>
<td align="center">线程指针（Thread Pointer），用于线程局部存储（TLS）</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><code>x5</code>-<code>x7</code></td>
<td align="center"><code>t0</code>-<code>t2</code></td>
<td align="center">临时寄存器，用于短期存储，函数调用后可能被覆盖</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"><code>x8</code></td>
<td align="center"><code>s0</code>&#x2F;<code>fp</code></td>
<td align="center">帧指针（Frame Pointer），用于调试或栈帧定位（可选）</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><code>x9</code></td>
<td align="center"><code>s1</code></td>
<td align="center">保存寄存器，函数调用后需恢复</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><code>x10</code>-<code>x11</code></td>
<td align="center"><code>a0</code>-<code>a1</code></td>
<td align="center">函数参数&#x2F;返回值，传递前两个参数或返回值</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"><code>x12</code>-<code>x17</code></td>
<td align="center"><code>a2</code>-<code>a7</code></td>
<td align="center">函数参数，传递第 3~8 个参数</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"><code>x18</code>-<code>x27</code></td>
<td align="center"><code>s2</code>-<code>s11</code></td>
<td align="center">保存寄存器，函数调用后需恢复</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><code>x28</code>-<code>x31</code></td>
<td align="center"><code>t3</code>-<code>t6</code></td>
<td align="center">临时寄存器，函数调用后可能被覆盖</td>
<td align="center">否</td>
</tr>
</tbody></table>
<ul>
<li>“是否调用保存”指的是，发送函数调用时，是否会保存该寄存器的值，还是直接覆盖</li>
</ul>
<h4 id="浮点寄存器"><a href="#浮点寄存器" class="headerlink" title="浮点寄存器"></a>浮点寄存器</h4><p>如果实现 <code>F</code> 或 <code>D</code> 扩展（单精度&#x2F;双精度浮点），RISC-V 提供 <strong>32 个浮点寄存器</strong> <code>f0</code>-<code>f31</code>，位宽由扩展决定：</p>
<ul>
<li><code>F</code> 扩展：32 位（单精度）</li>
<li><code>D</code> 扩展：64 位（双精度）</li>
</ul>
<h4 id="状态控制寄存器"><a href="#状态控制寄存器" class="headerlink" title="状态控制寄存器"></a>状态控制寄存器</h4><ul>
<li><p>不同的特权级别分别对应<strong>各自</strong>的一套状态控制寄存器CSRs，用于配置和监控 CPU 状态（&#x3D;&#x3D;具体有哪些&#x3D;&#x3D;，请看RISC-V ISA手册Part2的Table 2.2）</p>
</li>
<li><p>高级别的特权级别下可以访问低级别的CSR， 譬如 Machine Level 下可以访问  Supervisor&#x2F;User Level 的 CSR，以此类推， 但反之不可以</p>
</li>
<li><p>RISC-V 定义了专门用于操作 CSR 的指令</p>
</li>
<li><p>RISC-V 定义了特定的指令可以用于在不同特权级别之间进行切换</p>
</li>
</ul>
<h2 id="3-RISC-V-ABI"><a href="#3-RISC-V-ABI" class="headerlink" title="3.RISC-V ABI"></a>3.RISC-V ABI</h2><p>ABI（Application Binary Interface，应用程序二进制接口）是<strong>软件组件之间的底层交互规范</strong>，定义了程序如何编译、链接、执行，以及不同模块（如应用程序、库、操作系统）之间的二进制兼容性规则。之所以叫做二进制接口，是因为它和在同一种编程语言内部调用接口不同，是<strong>汇编指令级</strong>的一种接口。它介于硬件（ISA）和高级语言（如C&#x2F;C++）之间，直接影响程序的运行行为。</p>
<ul>
<li>ABI是S-Mode为U-Mode提供的接口，而SBI是M-Mode为S-Mode提供的接口</li>
</ul>
<img src="../assets/image-20250421201235592.png" alt="image-20250421201235592" style="zoom:50%;" />

<p>核心内容：</p>
<ul>
<li>函数调用约定（Calling Convention）：参数如何通过寄存器&#x2F;栈传递（如 RISC-V 用 <code>a0</code>-<code>a7</code>）</li>
<li>系统调用约定：系统调用号存放位置（如 RISC-V 用 <code>a7</code>）</li>
<li>数据对齐和结构体布局</li>
<li>寄存器保存规则（哪些寄存器由调用者&#x2F;被调用者保存）</li>
</ul>
<h3 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h3><p>这部分内容如上面的寄存器表格定义，值得注意的是，由于ABI是<strong>汇编</strong>级别的约定，所以我们普通程序员基本上是不用太关注的，比如函数使用哪个寄存器传参，<strong>编译</strong>的的时候编译器就已经帮我们生成了这部分（把参数存到a_x寄存器里）的汇编代码了</p>
<ul>
<li><p>参数传递规则：</p>
<ul>
<li><p>整数参数：通过 <code>a0</code>-<code>a7</code> 传递（前 8 个），超出部分通过栈传递</p>
</li>
<li><p>浮点参数：通过 <code>fa0</code>-<code>fa7</code> 传递（前 8 个），超出部分通过栈传递</p>
</li>
<li><p>混合参数：整数和浮点参数分开传递</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><p>整数返回值：存放在 <code>a0</code>（和 <code>a1</code>，如果 64 位值）</p>
</li>
<li><p>浮点返回值：存放在 <code>fa0</code>（和 <code>fa1</code>，如果双精度）</p>
</li>
</ul>
</li>
<li><p>栈帧管理：</p>
<ul>
<li><p>栈对齐：栈指针 <code>sp</code> 必须保持 16 字节对齐</p>
</li>
<li><p>保存寄存器：被调用者（Callee）需保存 <code>s0</code>-<code>s11</code> 和 <code>fs0</code>-<code>fs11</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="上下文保存"><a href="#上下文保存" class="headerlink" title="上下文保存"></a>上下文保存</h4><ul>
<li><p><code>ra</code>（return address）：函数调用会发生指令跳转，该寄存器保存了跳转前的PC寄存器的值，以便函数执行完时跳转回去继续执行</p>
</li>
<li><p><code>fp</code>（frame pointer）：存储当前栈帧的地址</p>
</li>
<li><p><code>sp</code>（stack pointer）：存储当前栈底部的地址</p>
</li>
</ul>
<hr>
<ul>
<li>栈（Stack）：用户进程内存空间的一个重要分区，通常自顶向下生长，由<code>sp</code>指针指向当前栈底的位置。每个线程都有独立的、固定大小的栈，所以一个用户进程会有多个栈区</li>
<li>栈帧（Stack Frame）：是计算机程序在执行过程中，用于存储单个函数调用相关信息（包括：当前的局部变量，函数的返回地址，上一个栈帧的地址，函数跳转前的各个寄存器的值）的一块内存区域。每当一个<strong>函数被调用时</strong>，一个新的栈帧会被压入调用栈；当函数返回时，对应的栈帧会被弹出，其实就是函数调用时被保存的<strong>上下文</strong>。由<code>fp</code>寄存器存储当前栈帧的起始地址</li>
</ul>
<p>从汇编的角度看函数调用：</p>
<img src="../assets/image-20250422095739093.png" alt="image-20250422095739093" style="zoom:67%;" />

<ul>
<li><p>Stack Frame必须要被汇编代码创建，所以是编译器生成了汇编代码，进而创建了Stack Frame。对<code>sp</code>的减小和增大，其实就是Stack Frame的压栈（创建）和出栈（删除）</p>
</li>
<li><p>不同函数调用时，分配的栈帧大小是不同的，这和需要保存的局部变量和寄存器相关，但至少得包含存储<code>ra</code>和上个<code>fp</code>寄存器的大小（上面的代码中，栈帧大小为16字节）</p>
</li>
</ul>
<p>某线程的栈区的示意图：由3个栈帧组成</p>
<img src="../assets/image-20241030114804228.png" alt="image-20241030114804228" style="zoom:50%;" />

<h3 id="系统调用约定"><a href="#系统调用约定" class="headerlink" title="系统调用约定"></a>系统调用约定</h3><ul>
<li>系统调用号：存放在 <code>a7</code></li>
<li>参数：通过 <code>a0</code>-<code>a5</code> 传递（&#x3D;&#x3D;最多 6 个&#x3D;&#x3D;）</li>
<li>返回值：成功时返回 <code>a0</code>，错误时返回 <code>-errno</code>（类似 Linux）</li>
</ul>
<h3 id="数据布局与对齐"><a href="#数据布局与对齐" class="headerlink" title="数据布局与对齐"></a>数据布局与对齐</h3><p>基本类型大小：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">RV32</th>
<th align="center">RV64</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>int</code></td>
<td align="center">4 字节</td>
<td align="center">4 字节</td>
</tr>
<tr>
<td align="center"><code>long</code></td>
<td align="center">4 字节</td>
<td align="center">8 字节</td>
</tr>
<tr>
<td align="center">指针</td>
<td align="center">4 字节</td>
<td align="center">8字节</td>
</tr>
<tr>
<td align="center"><code>double</code></td>
<td align="center">8 字节</td>
<td align="center">8 字节</td>
</tr>
<tr>
<td align="center"><code>float</code></td>
<td align="center">4 字节</td>
<td align="center">4 字节</td>
</tr>
</tbody></table>
<p>结构体对齐：</p>
<ul>
<li>默认对齐规则：字段按自身大小对齐（如 <code>int</code> 对齐到 4 字节）</li>
</ul>
<h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec05-calling-conventions-and-stack-frames-risc-v/5.4-risc-v-ji-cun-qi">5.4 RISC-V寄存器 | MIT6.S081</a></li>
<li><a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec05-calling-conventions-and-stack-frames-risc-v/5.5-stack">5.5 Stack | MIT6.S081</a></li>
</ul>
<h2 id="4-Trap"><a href="#4-Trap" class="headerlink" title="4.Trap"></a>4.Trap</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>用于将程序从用户态切换到内核态的事件，它是操作系统实现<strong>特权隔离</strong>和<strong>安全控制</strong>的核心机制之一</p>
<h3 id="触发场景"><a href="#触发场景" class="headerlink" title="触发场景"></a>触发场景</h3><p>Trap 通常由以下3类事件触发：</p>
<p>1.系统调用（Syscall）</p>
<ul>
<li>用户程序主动请求内核服务（如读写文件、创建进程等），通过 <code>ecall</code>（RISC-V）或 <code>syscall</code>（x86-64）指令触发</li>
<li>例如：Linux 中调用 <code>write()</code> 会触发 Trap，进入内核的 <code>sys_write</code> 处理函数</li>
</ul>
<p>2.异常（Exception）</p>
<ul>
<li>由程序执行错误（如除零、非法内存访问）或调试需求（如断点）触发</li>
<li>例如：访问 <code>NULL</code> 指针会触发 缺页异常（Page Fault）或 段错误（Segmentation Fault）</li>
</ul>
<p>RISC-V包含的异常如下（<code>scause</code>寄存器的值）：</p>
<table>
<thead>
<tr>
<th align="center">异常代码</th>
<th align="center">助记符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">指令地址未对齐 (Instruction address misaligned)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">指令访问错误 (Instruction access fault)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">非法指令 (Illegal instruction)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">断点 (Breakpoint)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">加载地址未对齐 (Load address misaligned)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">5</td>
<td align="center">加载访问错误 (Load access fault)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">6</td>
<td align="center">存储&#x2F;原子操作地址未对齐 (Store&#x2F;AMO address misaligned)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">7</td>
<td align="center">存储&#x2F;原子操作访问错误 (Store&#x2F;AMO access fault)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">8</td>
<td align="center">用户模式系统调用 (Environment call from U-mode)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">9</td>
<td align="center">监管模式系统调用 (Environment call from S-mode)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">11</td>
<td align="center">机器模式系统调用 (Environment call from M-mode)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">12</td>
<td align="center">指令页错误 (Instruction page fault)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">13</td>
<td align="center">加载页错误 (Load page fault)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">15</td>
<td align="center">存储&#x2F;原子操作页错误 (Store&#x2F;AMO page fault)</td>
</tr>
</tbody></table>
<p>3.中断（Interrupt）</p>
<ul>
<li>由外部设备（如键盘、定时器）异步触发</li>
</ul>
<blockquote>
<p>系统调用和异常的触发是<strong>同步</strong>的，而中断是<strong>异步</strong>的</p>
</blockquote>
<h3 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h3><ul>
<li>MODE：当前CPU的特权模式</li>
<li>SATP：当前MMU所使用页表的基址</li>
<li>STVEC：内核中处理Trap的指令的地址</li>
<li>SEPC：备份发生Trap时PC指针的值，结束时返回</li>
<li>SSCRATCH：临时存储数据，通常用于上下文保存时，切换用户&#x2F;内核栈，相当于一个cache</li>
<li>SCAUSE：保存了trap是什么类型（中断&#x2F;系统调用&#x2F;异常）</li>
<li>SSTATUS：中断使能控制；trap发生时的特权级保存；sret返回时的特权级设置</li>
<li>32个通用寄存器：作为上下文被保存</li>
</ul>
<blockquote>
<p>需要注意的是这些寄存器是S态的CSR寄存器。M态还有一套自己的CSR寄存器mcause，mtvec…</p>
</blockquote>
<h3 id="Trap的处理流程"><a href="#Trap的处理流程" class="headerlink" title="Trap的处理流程"></a>Trap的处理流程</h3><p>Trap的处理流程由OS决定，不同OS一般不同，下面以XV6的系统调用为例：</p>
<img src="../assets/image-20241028165555484.png" alt="image-20241028165555484" style="zoom: 67%;" />

<p><strong>从用户态U跳转到内核态S</strong></p>
<ul>
<li>用户态程序将<code>a7</code>存放系统调用号，<code>a0 - a5</code>存放系统调用的参数，并调用<code>ecall</code>指令触发特权等级的切换，调用完毕后会将系统调用的返回值放在<code>a0</code>寄存器中</li>
<li>cpu会自动修改<code>sepc</code>寄存器的值为执行<code>ecall</code>后的下一条指令的地址，用于当系统调用完毕后从内核态返回跳转到此地址继续执行代码</li>
<li><code>scause</code>寄存器会被cpu修改成产生此次<code>trap</code>的原因，比如<code>scause</code>为8时代表为U模式下的系统调用</li>
<li>在系统刚启动、从内核空间进入到用户空间之前，内核会设置好STVEC寄存器指向内核希望<code>trap</code>代码运行的位置，这样通过<code>ecall</code>陷入到内核态时就会去<code>stvec</code>中保存的地址开始执行代码</li>
</ul>
<p><strong>内核态处理流程</strong></p>
<ul>
<li>当<code>ecall</code>进入内核态后，内核需要保存用户态的寄存器以便在结束系统调用后恢复用户态的执行逻辑，但是XV6的用户空间和内核的page table不同，在切换页表前，无法访问内核的地址空间，故无法在内核中备份寄存器的值。所以XV6引入了一个特殊的设计：内核在创建一个进程时会动态分配一个物理页（trap frame page），其PTE的权限设置为只能在S-mode下访问，并将其映射到用户页表中。这样就可实现在发生<code>trap</code>并还没切换页表时，实现用户寄存器的备份</li>
<li>进入内核态后<code>sscratch</code>寄存器中保存了<strong>用户页表</strong>的<code>trapframe</code>的虚拟地址，将其与<code>a0</code>寄存器交换，接着依次保存<code>x0-x31</code>的所有寄存器以及S态的<code>sstatus</code>和<code>sepc</code>寄存器保存到该内存页中</li>
<li>将用户态的寄存器保存后，内核从<code>trapframe</code>读取内核页表的基址，实现页表的切换，并将<code>sp</code>指向内核栈</li>
<li>之后执行<code>trap</code>的具体处理流程<code>syscall()</code>，根据<code>p-&gt;trapframe</code>访问内核中备份的用户进程的各寄存器的值。首先判断取出<code>a7</code>寄存器中的系统调用号进行分发，然后再将<code>a0-a5</code>系统调用的参数取出随之去进行处理，并将结果存到<code>p-&gt;trapframe-&gt;a0</code></li>
</ul>
<p><strong>从内核态S跳转到用户态U</strong></p>
<ul>
<li>首先从<code>trapframe</code>中恢复<code>x0-x31</code>寄存器，将<code>sp</code>指向用户栈，然后将<code>sscratch</code>中的值设置为用户页表中<code>trapframe</code>的地址</li>
<li>在返回到用户态之前需要设置<code>sstatus</code>的<code>SPP</code>位为0告诉cpu将特权等级设置为U模式</li>
<li>将用户页表的基址写入 <code>satp</code> ，切换页表并清空页表缓存</li>
<li>调用<code>sret</code>返回到用户态，<code>pc</code>返回到之前<code>sepc</code>寄存器中保存的地址</li>
</ul>
<h3 id="新增系统调用的流程"><a href="#新增系统调用的流程" class="headerlink" title="新增系统调用的流程"></a>新增系统调用的流程</h3><ul>
<li>(1)在&#x3D;&#x3D;用户空间&#x3D;&#x3D;创建一个与系统调用同名的<strong>存根</strong>函数，这个函数通过<strong>汇编</strong>实现，在被调用的时候，会将<strong>系统调用号</strong>放到a7寄存器中，并调用<code>ecall</code>指令触发一个trap</li>
<li>(2)在内核空间中有个数组存了所有系统调用的编号，在此数组中新增新的编号，对应用户新添加的系统调用</li>
<li>(3)kernel中实现<code>sys_xxx</code>，作为系统调用的真正实现</li>
</ul>
<blockquote>
<p>内核会在<code>trap</code>的处理中，调用<code>syscall()</code>并通过a7寄存器里存的编号来调用真正的系统调用</p>
</blockquote>
<h3 id="为什么每个用户进程的页表中都要映射trampoline和trapframe"><a href="#为什么每个用户进程的页表中都要映射trampoline和trapframe" class="headerlink" title="为什么每个用户进程的页表中都要映射trampoline和trapframe"></a>为什么每个用户进程的页表中都要映射trampoline和trapframe</h3><p>RISC-V在执行<code>ecall</code>指令时并不会切换页表，而是让CPU进入SVC模式，并触发一个<code>trap</code>，程序将自动跳转到<code>STVEC</code>寄存器所指的地址的指令。此时的页表还是<strong>用户进程的页表</strong>，而后会切换到<strong>内核页表</strong>。但是在切换页表的过程中，<code>pc</code>始终在<code>uservec()</code>函数内，为了让程序能在切换了地址空间后继续正常地执行该函数，需要在2个页表中都建立对该函数所在物理页(traponline)的映射</p>
<ul>
<li>注意，虽然用户进程的页表有这2个内核页表项的映射，但是在CPU处于User Mode的时候并不能访问，因为他们的<code>PTE_U</code>标志位没有置位，这保证了trap的安全性</li>
<li>只有在trampoline的代码段能实现页表的切换，因为内核和用户进程的页表，只在trampoline处有相同的PTE(虚拟地址、物理地址都一样)，即切换页表后能继续执行后边的指令</li>
</ul>
<h3 id="Trap时如何保存上下文"><a href="#Trap时如何保存上下文" class="headerlink" title="Trap时如何保存上下文"></a>Trap时如何保存上下文</h3><p>在每个用户进程的页表中，都保存了一个trap frame page，其地址被存在<code>SSCRATCH</code>寄存器里。该页表项可以用来保存和恢复用户态CPU的通用寄存器的值；并且该页表项也保存了内核页表的地址，以便后续切换页表</p>
<blockquote>
<p>为什么需要保存上下文？</p>
<ul>
<li>因为在进入内核态后，内核将覆盖所有CPU寄存器的值，如果我们想在处理完trap后正确地恢复用户进程，则需要备份当前的寄存器的值</li>
</ul>
<p>为什么不在栈中保存上下文？</p>
<ul>
<li>1.防止用户程序恶意修改栈的数据，而导致内核恢复上下文的时候读取到被篡改的数据</li>
<li>2.简化上下文切换的流程</li>
</ul>
</blockquote>
<h3 id="系统调用如何传递参数"><a href="#系统调用如何传递参数" class="headerlink" title="系统调用如何传递参数"></a>系统调用如何传递参数</h3><p>向内核传递的参数会自动被放到<code>a0</code>~&#96;a5<code>通用寄存器中，并在由用户态切换到内核态时，被保存在</code>p-&gt;trapframe&#96;中。在内核中通过读取这几个寄存器的值来得到系统调用的传递的参数</p>
<h3 id="XV6处理异常的方法"><a href="#XV6处理异常的方法" class="headerlink" title="XV6处理异常的方法"></a>XV6处理异常的方法</h3><ul>
<li>异常发生在用户进程：直接kill了该进程</li>
<li>异常发生在内核：发生kernel panic</li>
</ul>
<blockquote>
<p>真实操作系统远比这复杂</p>
</blockquote>
<h3 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec06-isolation-and-system-call-entry-exit-robert">Lec06 Isolation &amp; system call entry&#x2F;exit (Robert) | MIT6.S081</a></li>
<li><a target="_blank" rel="noopener" href="https://learningos.cn/uCore-Tutorial-Guide-2024S/chapter2/2application.html">实现应用程序以及user文件夹 - uCore-Tutorial-Guide-2024S 文档</a></li>
</ul>
<h2 id="5-中断管理"><a href="#5-中断管理" class="headerlink" title="5.中断管理"></a>5.中断管理</h2><h3 id="如何对硬件设备编程"><a href="#如何对硬件设备编程" class="headerlink" title="如何对硬件设备编程"></a>如何对硬件设备编程</h3><p>每个硬件设备都有个固定的物理地址（这又设备厂商决定）通过对这些物理地址执行CPU的load、store指令，即读写设备的控制寄存器，即可完成对设备的编程</p>
<p>由于OS无法直接访问物理地址，所以在对硬件编程时，通常要和操作内存一样，需要创建个PTE来获得一个与设备物理地址对应的虚拟地址，后续通过该虚拟地址来对寄存器进行读写</p>
<h3 id="中断相关的寄存器"><a href="#中断相关的寄存器" class="headerlink" title="中断相关的寄存器"></a>中断相关的寄存器</h3><ul>
<li>SIE(Supervisor Interrupt Enable)：有一个bit用于开启&#x2F;关闭<strong>某个</strong>中断（外部设备、定时器、软件等）</li>
<li>SSTATUS(Supervisor Status)：有一个bit用于开启&#x2F;关闭<strong>所有</strong>中断</li>
<li>SIP(Supervisor Interrupt Pending)：用于查看发生的是什么中断</li>
<li>SCAUSE：表明当前进入trap的原因</li>
<li>STVEC：内核中处理Trap的指令的地址</li>
<li>SEPC：保存被打断的指令以便结束trap后继续执行</li>
</ul>
<h3 id="中断的路由"><a href="#中断的路由" class="headerlink" title="中断的路由"></a>中断的路由</h3><ul>
<li>当一个中断产生，它是如何被送到某个CPU中的，这被称为中断的路由</li>
<li>在RISC-V中这个过程由PLIC（platform level interrupt controller）平台中断控制器来控制，即PLIC掌管了中断的接收和分发</li>
</ul>
<h3 id="中断太频繁怎么办"><a href="#中断太频繁怎么办" class="headerlink" title="中断太频繁怎么办"></a>中断太频繁怎么办</h3><p>如果使用了高速设备，那么设备产生中断的频率可能非常高。比如千兆网卡可能1us就会接收到一个数据进而产生一个中断，如果还像低速设备那样每接收到一次数据就发生一个trap然后CPU去读外设寄存器来将数据存到内存里，那么效率就太低了，对于此问题有以下解决办法：</p>
<ul>
<li>1.关闭中断，使用轮训的方式去读寄存器，这样一次可能可以读多条数据，也可能没有数据而浪费CPU的时间</li>
<li>2.<strong>使用DMA</strong>(直接内存映射)，DMA可以把外设寄存器的值直接映射到内存中，省去了CPU先发生trap，然后执行load指令读取外设寄存器的时间</li>
</ul>
<h2 id="6-内存管理"><a href="#6-内存管理" class="headerlink" title="6.内存管理"></a>6.内存管理</h2><h3 id="相关硬件"><a href="#相关硬件" class="headerlink" title="相关硬件"></a>相关硬件</h3><ul>
<li>MMU<ul>
<li>仅在U-Mode和S-Mode使用，M-Mode下直接访问物理内存</li>
<li>MMU不保存页表，它只会保存根页表的物理地址（类似指针）</li>
</ul>
</li>
<li>stap寄存器：控制MMU的开启&#x2F;关闭、根页表的地址、分页模式。其字段组成如下：| MODE (4 bits) | ASID (16 bits) | PPN (44 bits) |<ul>
<li>MODE：分页模式（如 <code>8</code> 表示 Sv39）</li>
<li>ASID：地址空间标识符（可选，用于 TLB 隔离）</li>
<li>PPN：根页表的物理地址，实际不是完整的物理地址，只是物理页号，page directory的offset都为0所以省略了。</li>
</ul>
</li>
<li>TLB<ul>
<li>修改<code>satp</code>之后，必须通过<code>sfence.vma</code>清空TLB的缓存</li>
</ul>
</li>
<li>物理内存<ul>
<li>CPU访问物理内存是以<strong>字节</strong>为单位访问的，但是OS以及MMU却以<strong>页</strong>为单位对物理内存进行管理&#x2F;翻译</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">场景</th>
<th align="center">访问&#x2F;管理单位</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CPU 指令访问内存</td>
<td align="center">字节</td>
<td align="center"><code>lw a0, 4(sp)</code> 读取 <code>sp+4</code> 地址的 4 字节数据</td>
</tr>
<tr>
<td align="center">OS分配内存</td>
<td align="center">页（如 4KB）</td>
<td align="center">xv6 的 <code>kalloc()</code> 返回一个 4096 字节的物理页</td>
</tr>
<tr>
<td align="center">MMU 地址转换</td>
<td align="center">页</td>
<td align="center">虚拟地址 <code>0x1000</code>-<code>0x1FFF</code> → 物理页帧 <code>0x5000</code>（通过 PTE 映射）</td>
</tr>
</tbody></table>
<h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><h4 id="RISC-V地址空间"><a href="#RISC-V地址空间" class="headerlink" title="RISC-V地址空间"></a>RISC-V地址空间</h4><img src="../assets/image-20241029155505711.png" alt="image-20241029155505711" style="zoom: 80%;" />

<p>如右图所示，在整个RISCV的地址空间中，物理内存从0x80000000开始，所以内核加载到此地址</p>
<h4 id="内核空间内存布局"><a href="#内核空间内存布局" class="headerlink" title="内核空间内存布局"></a>内核空间内存布局</h4><p>XV6内核的内存布局如左图所示，它和物理内存是<strong>直接映射</strong>的。XV6和Linux的内核布局有很大的区别，XV6中内核维护了一个单独的页表，独立于用户进程。而Linux中每个进程地址空间的<strong>高位</strong>包含了对于内核代码和数据的映射，即用户页表直接包含了对内核的映射，不过用户态下无权访问</p>
<h4 id="用户进程内存布局"><a href="#用户进程内存布局" class="headerlink" title="用户进程内存布局"></a>用户进程内存布局</h4><img src="../assets/image-20241029155440781.png" alt="image-20241029155440781" style="zoom:67%;" />

<p>用户进程和内核的内存布局(页表)的区别</p>
<p>(1)映射内容：</p>
<ul>
<li>内核页表：映射整个内核地址空间，包括内核代码段、内核数据段、硬件外设的寄存器以及内核栈等</li>
<li>用户进程页表：包括用户程序的代码段、数据段、堆和栈</li>
</ul>
<p>(2)地址范围：</p>
<ul>
<li>内核页表：从0x0000开始，但是低地址部分是硬件外设寄存器的映射，内核代码是从0x80000000开始的</li>
<li>用户进程页表：也从0x0000开始，低地址部分直接就是用户程序的代码段</li>
</ul>
<blockquote>
<p>debug时通过当前指令的地址，就能判断是在内核还是用户进程中了</p>
</blockquote>
<p>(3)生命周期和管理方式：</p>
<ul>
<li>内核页表：在系统启动时被创建，一直存在，且相对静态，只会微调，比如加载新的内核模块</li>
<li>用户进程页表：在用户进程创建时被创建，结束时被销毁，且会随着内存分配动态变化，内核会根据进程的内存申请（如<code>malloc</code>操作）和释放（如<code>free</code>操作）来动态地更新页表</li>
</ul>
<h3 id="页表与地址转换"><a href="#页表与地址转换" class="headerlink" title="页表与地址转换"></a>页表与地址转换</h3><p>页表的定义：OS所维护的一种数据结构，保存了<strong>虚拟</strong>内存地址到<strong>物理</strong>内存地址的映射。基于页表，MMU才能正常的工作</p>
<ul>
<li>不同OS对于页表的管理也有很大的区别：<ul>
<li>比如XV6对内核维护了个单独的全局页表，实现对内核地址空间的映射；对每个进程各自维护了一个页表，实现对该进程用户空间进行映射</li>
<li>Linux每个进程的页表同时包含了用户空间和内核空间的映射</li>
</ul>
</li>
</ul>
<blockquote>
<p>页表是以&#x3D;&#x3D;内存页&#x3D;&#x3D;为粒度进行映射的，就如它的名字一样，并不是以字节为单位映射</p>
</blockquote>
<p>引入页表的作用：</p>
<p>(1)实现虚拟内存：物理内存资源是有限的。虚拟内存技术允许程序使用比实际物理内存更大的地址空间。通过页表，操作系统可以将虚拟地址空间映射到物理内存空间。比如一个32位机器的物理内存只有1G，但通过虚拟内存，其内存的地址空间可达到4G，页表可以将虚拟地址空间中的页面映射到物理内存中的页面或者磁盘上的交换空间（当物理内存不足时），使得程序能够正常运行，就好像拥有足够的物理内存一样</p>
<p>(2)实现内存的隔离：通过给每个进程实现一个独立的页表，不同进程之间就无法直接访问对方的内存空间，从而防止一个进程意外访问或修改另一个进程的内存数据</p>
<p>(3)实现访问控制：页表项除了保存了虚拟地址到物理地址的转换关系，还保存了此页表项的访问权限，比如有的页表项就只能在内核中访问，用户空间无法访问。可以防止用户修改内核的内存，或者修改未被分配的内存空间，提供了一种保护机制</p>
<h4 id="RISC-V的分页机制"><a href="#RISC-V的分页机制" class="headerlink" title="RISC-V的分页机制"></a>RISC-V的分页机制</h4><p>RISC-V ISA支持多种分页机制，通过<code>satp</code>寄存器控制，XV6使用的是Sv39分页机制，除此之外还有Sv32、Sv48等分页机制</p>
<p><strong>为什么要引入多级页表？</strong></p>
<p>多级页表是现代操作系统管理虚拟内存的核心机制，其设计目的是为了解决<strong>单级页表空间浪费严重</strong>的问题，同时兼顾<strong>查找效率</strong>和<strong>灵活性</strong>。下面分析单级页表的内存占用：</p>
<ul>
<li>Sv39 的虚拟地址空间大小：2^39&#x3D;512GiB</li>
<li>页大小：4KiB</li>
<li>页表项大小：8 B</li>
</ul>
<p>那么：</p>
<ul>
<li>虚拟页数 &#x3D; 2^39&#x2F;2^12 &#x3D; 2^27&#x3D;134,217,728 个页</li>
<li>单级页表大小 &#x3D; 2^27 * 8B&#x3D;1GB</li>
</ul>
<p>对于每个进程，即使该进程只用了很小的内存，OS都需要维护这么大一个页表，非常浪费空间！</p>
<p>所以OS引入了多级页表，对于多级页表，OS只会固定分配L2 Page Directory的内存(512*8&#x3D;4KB)，L1和L0的Page Directory都是动态分配的，所以最小只需要3 * 4&#x3D;12KB的内存来存储页表</p>
<h4 id="虚拟地址结构"><a href="#虚拟地址结构" class="headerlink" title="虚拟地址结构"></a>虚拟地址结构</h4><p>Sv39是一种三级页表机制，支持<strong>39</strong>位的虚拟地址空间(最大支持512GB的虚拟内存)，这39位的虚拟地址又分为以下5部分：</p>
<ul>
<li><p>保留区：25位</p>
</li>
<li><p>页内偏移（12位）：4KB 页大小（4096 字节）</p>
</li>
<li><p>三级页表索引（各 9 位）：</p>
<ul>
<li>L2 Page Directory Index（Page Directory指的是多级页表中的某一级页表）</li>
<li>L1 Page Directory Index</li>
<li>L0 Page Directory Index</li>
</ul>
</li>
</ul>
<blockquote>
<p>我们看到的虚拟地址通常是64位，因为XV6是在RV64的板子上的，但是虚拟地址实际上<strong>只有低39位有效</strong></p>
</blockquote>
<img src="../assets/image-20250423152220808.png" alt="image-20250423152220808" style="zoom:80%;" />

<p><strong>虚拟地址-&gt;物理地址的翻译过程</strong>：</p>
<ul>
<li><p>首先MMU根据<code>satp</code>获得L2 Page Directory的物理地址，然后根据虚拟地址的L2 Index从中找出对应的PTE2，该PTE保存了L1 Page Directory的物理地址(PPN)</p>
</li>
<li><p>接着从物理内存中找到L1 Page Directory，并结合L1 Index从中找出对应的PTE1，该PTE保存了L0 Page Directory的物理地址</p>
</li>
<li><p>接着从物理内存中找到L0 Page Directory，并结合L0 Index从中找出对应的PTE0，该PTE保存了目标物理页的地址，并结合虚拟地址的低12位获得页内偏移，最终得到完整的物理地址</p>
</li>
</ul>
<p>“虚拟地址-&gt;物理地址的翻译”是<strong>MMU硬件</strong>帮我们完成的，但是XV6实现了一个函数<code>walk()</code>来<strong>软件模拟</strong>这个过程，因为有的时候内核中要访问用户空间（比如<code>copy_in()</code>），而此时<code>satp</code>寄存器里设置的是内核页表，所以就需要一个函数能够在内核中实现用户页表的地址翻译</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *<span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="物理地址结构"><a href="#物理地址结构" class="headerlink" title="物理地址结构"></a>物理地址结构</h4><p>如上图右侧，RISC-V的物理地址为<strong>56</strong>位，分为以下3部分：</p>
<ul>
<li><p>保留区：8位</p>
</li>
<li><p>物理页号(PPN)：高44位</p>
</li>
<li><p>页内偏移(offset)：低12位（待访问字节位于一页的哪里，其实很好理解，一页为4096字节&#x3D;2^12）</p>
</li>
</ul>
<blockquote>
<ul>
<li><p>我们看到的物理地址通常是64位，因为XV6是在RV64的板子上的，但是实际上<strong>只有低56位有效</strong></p>
</li>
<li><p>这样的分法是OS和MMU决定的，物理内存实际上并没有分页，直接按字节访问</p>
</li>
</ul>
</blockquote>
<h4 id="PTE结构"><a href="#PTE结构" class="headerlink" title="PTE结构"></a>PTE结构</h4><img src="../assets/image-20250423154801844.png" alt="image-20250423154801844" style="zoom:60%;" />

<p>PTE是Page Directory中的一项，每个PTE占用64位，主要分为以下3部分：</p>
<ul>
<li>保留区[63:53]：10位</li>
<li>物理页号(PPN)[53:10]：44位，通过左移再补12位的0(页内偏移)组成实际的物理地址</li>
<li>标志位[9:0]：10位</li>
</ul>
<table>
<thead>
<tr>
<th align="center">位</th>
<th align="center">名称</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">V (Valid)</td>
<td align="center">页表项是否有效。1&#x3D;有效，0&#x3D;无效（访问会触发<strong>缺页异常</strong>）</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">R (Read)</td>
<td align="center">是否可读。1&#x3D;允许读取该页数据</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">W (Write)</td>
<td align="center">是否可写。1&#x3D;允许写入该页（必须R&#x3D;1才能设置W&#x3D;1）</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">X (Execute)</td>
<td align="center">是否可执行。1&#x3D;允许执行该页代码（通常不与W同时设置，防止代码注入攻击）</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">U (User)</td>
<td align="center">用户权限。1&#x3D;用户态可访问，0&#x3D;仅内核态访问（用于内核隔离）</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">G (Global)</td>
<td align="center">全局页。1&#x3D;TLB全局缓存（所有进程共享，如内核代码），0&#x3D;仅当前进程有效</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">A (Accessed)</td>
<td align="center">访问标记。1&#x3D;该页曾被访问（用于<strong>页面置换</strong>算法），由MMU自动设置</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">D (Dirty)</td>
<td align="center">脏页标记。1&#x3D;该页曾被修改（<code>mmap</code>需<strong>写回</strong>磁盘时使用），由MMU自动设置</td>
</tr>
<tr>
<td align="center">8-9</td>
<td align="center">Reserved</td>
<td align="center">保留位（为内核的一些自定义功能保留）</td>
</tr>
</tbody></table>
<ul>
<li>A、D标志位由CPU自己维护，比如它可能会每100ms就清空所有PTE的该标志位，如果某个PTE又把它置1了，就说明最近访问过</li>
</ul>
<p><strong>PTE的标志位有什么用？</strong></p>
<ul>
<li>RWX：表明此页表项的读写权限</li>
<li>V：检测物理页是否被分配从而触发缺页异常</li>
<li>A：用于页面置换的控制</li>
<li>D：用于写回磁盘的控制</li>
</ul>
<h3 id="页表缓存-TLB"><a href="#页表缓存-TLB" class="headerlink" title="页表缓存(TLB)"></a>页表缓存(TLB)</h3><p>由于每次将一个虚拟地址转换成物理地址需要3次查表(Sv39中)，非常浪费时间，所以CPU内置了一个硬件用于对最近访问过的PTE进行缓存，在访问MMU之前，CPU会先访问TLB，查看是否要访问的虚拟地址已经被缓存了</p>
<p><strong>何时清空?</strong></p>
<p>在切换页表时，必须清空TLB，在RISC-V中是<code>sfence.vma</code>指令</p>
<h3 id="Page-Fault"><a href="#Page-Fault" class="headerlink" title="Page Fault"></a>Page Fault</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Page Fault（缺页异常）是一种由MMU引发的异常，对于在<code>trap handler</code>中对Page Fault进处理，是OS的重要工作之一。通过对Page Fault的合理应用，OS可以实现非常多有用的特性，从而优化OS的性能，比如Lazy Allocation、COW、mmap…（虽然XV6一个都没实现…）</p>
<hr>
<p><strong>触发Page Fault时内核需要的信息</strong>：</p>
<ul>
<li>引起page fault的<strong>虚拟地址</strong>（会被存到<code>STVAL</code>寄存器中）</li>
<li>引起page fault的原因（load&#x2F;store&#x2F;jump，会被存到<code>SCAUSE</code>寄存器中）</li>
<li>引起page fault的<code>pc</code>计数器值（会被存到<code>SEPC</code>寄存器中）</li>
</ul>
<hr>
<p><strong>Page Fault的分类</strong></p>
<p>根据访问的虚拟地址的合法性，Page Fault可分为以下2类：</p>
<p>（1）合法访问：当程序访问的虚拟内存地址<strong>有效</strong>，但对应的物理页面尚未加载到内存时，会触发合法的 Page Fault，操作系统会自动处理，并返回发生异常的地方重新执行，常见场景包括：</p>
<ul>
<li>首次访问未分配的页面<ul>
<li>程序刚申请内存（如 <code>malloc</code>），但尚未实际读写，操作系统采用<strong>惰性分配</strong>策略，首次访问时才分配物理页</li>
</ul>
</li>
<li>页面被换出到磁盘（Swap&#x2F;Pagefile）<ul>
<li>物理内存不足时，操作系统将不活跃的页面换出到磁盘（交换空间）。再次访问这些页面时，需从磁盘换回内存</li>
</ul>
</li>
<li>内存映射文件（Memory-Mapped File）<ul>
<li>通过 <code>mmap</code> 映射的文件，首次访问某部分内容时，需从磁盘加载对应数据到内存</li>
</ul>
</li>
<li>写时复制（Copy-on-Write, COW）<ul>
<li>进程调用 <code>fork()</code> 创建子进程时，父子进程共享只读页面。当某进程尝试写入时，触发 COW 机制，复制新页面并修改权限</li>
</ul>
</li>
</ul>
<p>（2）非法访问：当程序访问<strong>无效或受保护</strong>的地址时，会触发非法 Page Fault，通常导致程序崩溃（如段错误）。原因包括：</p>
<ul>
<li>访问无效的虚拟地址<ul>
<li>解引用空指针（<code>NULL</code>）、访问已释放的内存（悬垂指针）或越界访问数组</li>
</ul>
</li>
<li>权限冲突<ul>
<li>尝试写入只读页面（如代码段或 COW 页面未正确处理）</li>
<li>用户态程序访问内核态内存（如系统调用未正确传参）</li>
</ul>
</li>
<li>地址空间切换问题<ul>
<li>多线程&#x2F;多进程环境下，某线程访问了其他进程的地址空间（如线程同步失败）</li>
</ul>
</li>
</ul>
<h4 id="Copy-On-Write-fork"><a href="#Copy-On-Write-fork" class="headerlink" title="Copy On Write fork"></a>Copy On Write fork</h4><p>xv6在执行<code>fork</code>系统调用时，子进程会拷贝一份父进程的页表，并在物理内存上分配对应的内存。这样做有很大的缺点：</p>
<ul>
<li>速度很慢，导致父进程长时间阻塞</li>
<li>如果子进程执行<code>exec</code>,则从父进程拷贝来的很多内存都会被释放，就白拷贝了</li>
</ul>
<p>因此，现代OS在实现<code>fork</code>时，大多会实现一种“写时拷贝”的<code>fork</code>：</p>
<p>当父进程通过 <code>fork()</code> 创建子进程后，子进程会复制一份父进程的页表。父进程和子进程的页表会共享相同的物理内存页面，但<strong>这些共享的页面会被标记为只读</strong>。这就实现了：在没有写操作时可以共享物理内存，从而节省内存资源。但当父进程或子进程中的某个进程尝试<strong>写入</strong>这些页面时，会触发页面错误（page fault）<strong>异常</strong>并使内核对此进程进行如下操作：</p>
<ol>
<li>分配新的物理页面。</li>
<li>将原始页面的内容复制到新页面。</li>
<li>更新写入方的页表映射，使其指向新的物理页面并标记为可写。</li>
</ol>
<p>这种方式保证了写入后的页面不会影响到另一个进程，实现了写入时复制的效果</p>
<h4 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk"></a>sbrk</h4><p>首先要知道一点<code>kalloc</code>, <code>malloc</code>之类的API并不是系统调用，而是C的库函数，在XV6中，对内存中的堆区大小做动态管理的系统调用是<code>sbrk()</code>，通过传入的参数，该接口会动态地调整堆区的大小（XV6进程的数据结构中,会有一个变量存储：当前<strong>堆区顶部</strong>的虚拟地址(初始值为stack顶的虚拟地址)<code>p-&gt;sz</code>），并分配物理内存。在XV6中，这个系统调用是<code>eager</code> allocation</p>
<h4 id="Lazy-Allocation"><a href="#Lazy-Allocation" class="headerlink" title="Lazy Allocation"></a>Lazy Allocation</h4><p>定义：当用户在堆区分配内存时，OS并不会立即分配物理内存和创建相应的页表项、只是改变了<code>p-&gt;sz</code>的大小。当访问这些新的虚拟内存时，触发一个page fault，并在trap handler中分别物理内存和新建页表项及映射</p>
<p>优点：</p>
<ul>
<li>内存节省：如果分配的内存最终未被访问，物理内存将不被使用，避免浪费</li>
<li>提高性能：延迟分配可以减少不必要的内存分配操作，特别适用于大量内存申请但部分或不使用的场景。</li>
<li>提升初始化效率：减少初始化时的内存分配时间，因为系统只分配虚拟内存地址，而不做物理内存映射</li>
</ul>
<p>缺点：</p>
<ul>
<li>该方法导致了page fault的额外开销，包括了用户态&#x2F;内核态的切换</li>
</ul>
<h4 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h4><p>定义：操作系统在新创建一个进程时，不是一开始就在物理内存中分配这个进程所需要的总大小，而是在首次访问到某个数据时，触发一个page fault，再在物理内存中进行分配内存，并将对应的数据从磁盘加载到物理内存中</p>
<ul>
<li>优点：节省了内存消耗，并提高了进程的启动速度</li>
<li>缺点：需要多次从磁盘读取数据，速度较慢；增加了page fault的处理时间</li>
</ul>
<p><strong>哪些数据是在进程初始化的时候不分配物理内存的呢？</strong></p>
<ul>
<li>程序的BSS段(未初始化数据段)，该段内存中存储了未初始化的静态变量和全局变量。进程刚启动时，page table会将BSS段的所有虚拟地址映射到同一个PA，并设置PTE对应的标志位，在真正访问这些PTE时，才会触发Page Fault进而分配物理内存和修改PTE</li>
<li>Text和Data段，分别存储了代码指令和有初始值的静态遍历和全局变量，会为他们创建PTE但是标志位为invalid，当访问到这些PTE时会触发Page Fault，分配物理内存并从磁盘中加载数据进去</li>
</ul>
<h4 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h4><p>定义：OS是会使用大于实际物理内存大小的内存，因此页表中只有一部分的数据实际是存在RAM中的，另一部分是在磁盘的交换空间中，并且这些数据对应的页表项的”<strong>V</strong>“标志位被设置为0，当访问这些页表项时，会触发page fault，此时再为这些数据分配物理内存，并修改PTE的映射。但有的时候物理内存已经没有多余空间了，此时内核会将某个PTE的在物理内存中的数据转移到磁盘交换空间中，并修改其V标志位，以此来获得多余的物理内存空间</p>
<p><strong>当内存满了时，会把哪些页面的内存撤回呢？</strong></p>
<p>这其实就是跟缓存满了，新的缓存放到哪是一个问题，本质就是在问有哪些页面替换策略，比如：</p>
<ul>
<li>LRU：释放最近没被访问过的内存，通过PTE标志位的“Access”位来判断该内存最近是否被访问过，该bit每隔一段时间就会被刷新一次</li>
</ul>
<h4 id="Memory-Mapped-Files"><a href="#Memory-Mapped-Files" class="headerlink" title="Memory Mapped Files"></a>Memory Mapped Files</h4><p>当我们需要在用户空间中修改一个文件的时候，可以使用<code>mmap()</code>来把加载到内核空间的磁盘文件直接映射到用户空间，从而避免数据的在用户空间和内核空间之间的数据拷贝</p>
<blockquote>
<p>在使用外设时也会用到，因为Linux下一切皆文件，设备也是一种文件</p>
</blockquote>
<p>在内核实现<code>mmap</code>时，也可以利用Page Fault机制：<code>mmap</code> 在将文件或匿名内存映射到用户空间的虚拟地址空间时，<strong>不会立即分配物理内存或加载文件数据</strong>，而是依赖后续的Page Fault动态加载</p>
<p>现代OS通常提供<code>mmap(va,len,perm,flag,fd,offset...)</code>系统调用来实现此功能</p>
<p>当操作完成时，使用<code>unmap(va,len..)</code>会从页表中删除这些页的映射，OS会在后台把PTE中dirty bit被置位的页给写会磁盘</p>
<h3 id="物理内存的分配与回收"><a href="#物理内存的分配与回收" class="headerlink" title="物理内存的分配与回收"></a>物理内存的分配与回收</h3><p>XV6对于物理内存以<strong>页</strong>为单位进行管理，它并没有像Linux那样使用伙伴算法来减少内存页间的碎片，而是使用简单的“<strong>首次适应</strong>”算法分配物理页</p>
<p>它在内核中维护了一个空闲页的链表<code>kmem</code>，在系统初始化的时候被创建，并把内存中所有空闲的物理页的地址都保存在里面。其中每个空闲页的前八个字节是个指针，指向了下一个空闲页的地址。XV6对于物理内存的管理实际上就是对于该链表的增&#x2F;删操作。</p>
<blockquote>
<p>首次适应算法（First-Fit） 是一种内存分配策略，主要用于管理空闲内存块。它的核心思想是：从内存的起始地址开始顺序搜索，找到第一个能满足请求大小的空闲块，立即分配</p>
</blockquote>
<p>除了First-Fit，还有很多别的物理内存管理算法：</p>
<table>
<thead>
<tr>
<th align="center">算法名称</th>
<th align="center">工作原理</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">首次适应 (First Fit)</td>
<td align="center">从空闲链表头部开始查找，分配第一个满足大小的空闲块</td>
<td align="center">分配速度快，实现简单</td>
<td align="center">容易产生外部碎片</td>
<td align="center">FreeRTOS <code>heap_4.c</code></td>
</tr>
<tr>
<td align="center">最佳匹配 (Best Fit)</td>
<td align="center">遍历整个空闲链表，分配能满足需求的最小空闲块</td>
<td align="center">内存利用率较高</td>
<td align="center">速度慢，可能产生微小碎片</td>
<td align="center">FreeRTOS <code>heap_2.c</code>（已淘汰）</td>
</tr>
<tr>
<td align="center">最差匹配 (Worst Fit)</td>
<td align="center">总是分配最大的空闲块</td>
<td align="center">减少微小碎片产生</td>
<td align="center">大块内存容易被拆分</td>
<td align="center">特殊场景（如长期运行的大块分配）</td>
</tr>
<tr>
<td align="center">伙伴系统 (Buddy System)</td>
<td align="center">将内存划分为2的幂次方大小块，合并时只能与“伙伴”合并</td>
<td align="center">碎片少，合并效率高</td>
<td align="center">内存浪费（内部碎片）</td>
<td align="center">Linux 内核物理内存管理</td>
</tr>
<tr>
<td align="center">分离空闲链表 (Segregated Free Lists)</td>
<td align="center">按大小分类维护多个空闲链表（如 16B、32B、64B…）</td>
<td align="center">分配速度快，减少搜索时间</td>
<td align="center">需要预分配固定大小分类</td>
<td align="center">TLSF（实时内存分配器）</td>
</tr>
</tbody></table>
<h3 id="XV6中内存相关的函数"><a href="#XV6中内存相关的函数" class="headerlink" title="XV6中内存相关的函数"></a>XV6中内存相关的函数</h3><h4 id="物理内存分配与回收"><a href="#物理内存分配与回收" class="headerlink" title="物理内存分配与回收"></a>物理内存分配与回收</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kalloc.c */</span></span><br><span class="line"><span class="comment">// 分配一块物理内存返回其地址</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 释放给定地址的物理内存</span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="虚拟内存映射"><a href="#虚拟内存映射" class="headerlink" title="虚拟内存映射"></a>虚拟内存映射</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* vm.c */</span></span><br><span class="line"><span class="comment">// 创建内核的页表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 初始化页表相关寄存器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvminithart</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 给内核页表创建个PTE以添加一个映射</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定的VA和PA创建一个PTE完成映射</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="comment">// 创建一个空的用户页表</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">uvmcreate</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 加载用户进程的启动代码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmfirst</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uchar *src, uint sz)</span>;</span><br><span class="line"><span class="comment">// 给用户页表分配物理内存并创建PTE</span></span><br><span class="line">uint64 <span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="type">int</span> xperm)</span>;</span><br><span class="line"><span class="comment">// 删除用户页表的PTE</span></span><br><span class="line">uint64 <span class="title function_">uvmdealloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span>;</span><br><span class="line"><span class="comment">// 拷贝页表和物理内存(重新分配)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span>;</span><br><span class="line"><span class="comment">// 释放用户页表的给定大小的page</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmfree</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span>;</span><br><span class="line"><span class="comment">// 取消指定VA的映射关系(PTE置0),并释放物理内存(可选)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span>;</span><br><span class="line"><span class="comment">// 标记一个page为invalid(用于guard page)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmclear</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据VA查找页表项,如果没有的话且alloc!=0,就分配创建一个</span></span><br><span class="line"><span class="type">pte_t</span> * <span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span>;</span><br><span class="line"><span class="comment">// 根据VA查找其对应的PA</span></span><br><span class="line">uint64 <span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从内核的src虚拟地址拷贝len字节的数据到用户空间的dstva地址</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span>;</span><br><span class="line"><span class="comment">// 从用户空间的srcva地址拷贝len字节的数据到内核的dst虚拟地址</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span>;</span><br><span class="line"><span class="comment">// 从用户空间的srcva地址拷贝字符串到内核的dst虚拟地址</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">char</span> *, uint64, uint64)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接-3"><a href="#参考链接-3" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec04-page-tables-frans">Lec04 Page tables (Frans) | MIT6.S081</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec08-page-faults-frans">Lec08 Page faults (Frans) | MIT6.S081</a></p>
</li>
</ul>
<h2 id="7-进程管理"><a href="#7-进程管理" class="headerlink" title="7.进程管理"></a>7.进程管理</h2><h3 id="任务模型"><a href="#任务模型" class="headerlink" title="任务模型"></a>任务模型</h3><blockquote>
<p>从XV6或Linux内核的视角，进程和线程并没有区别，因为它们在内核的中的调度和管理方式是一致的。它们的区别主要在于资源的管理方式，后面用<strong>任务</strong>统称进程和线程</p>
</blockquote>
<ul>
<li>线程的定义：单个串行执行代码的单元，是CPU<strong>调度的基本单位</strong></li>
<li>线程在切换时需要保存一些上下文：<ul>
<li>PC指针</li>
<li>CPU寄存器</li>
<li>栈区（每个线程都有自己的栈区，各线程的栈的大小一般都是固定的。各进程的栈实际上都是被各个线程给分成了多份的）</li>
</ul>
</li>
</ul>
<img src="../assets/image-20241107165028767.png" alt="image-20241107165028767" style="zoom:67%;" />

<p>XV6中有2类线程：</p>
<ul>
<li>内核线程：每个用户线程都有一个内核线程来执行其发起的系统调用，而各内核线程都使用内核的页表，所以它们共享同一个内存空间</li>
<li>用户线程：由于XV6中每个进程都有自己独立的页表，所以不同进程的用户线程之间是独立的</li>
</ul>
<p>XV6与Linux的一样，一个用户线程对应一个内核线程，不是一对多或者多对多的关系。而且不是所有内核线程都有对应的用户线程，有的线程只运行与内核态，比如调度器线程</p>
<h3 id="任务的状态"><a href="#任务的状态" class="headerlink" title="任务的状态"></a>任务的状态</h3><p>XV6的任务分为以下几种状态：</p>
<ul>
<li>Running：正在CPU上运行，此时线程的PC指针、寄存器位于CPU中</li>
<li>Runnable：能够在CPU上运行，但还没得到CPU的控制权，此时线程的PC指针、寄存器位于RAM中</li>
<li>Sleeping：正在等待I&#x2F;O操作完成，此时并不想得到CPU控制权</li>
<li>Zombie：结束运行但是没有被释放资源</li>
</ul>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><ul>
<li><p>定义：停止一个线程的运行并启动另一个线程的运行</p>
</li>
<li><p>XV6为<strong>每个CPU核</strong>都创建了一个线程调度器（scheduler）</p>
</li>
</ul>
<p><strong>常见调度策略</strong>：指 “选择下一个运行任务的规则”</p>
<table>
<thead>
<tr>
<th align="center">调度策略</th>
<th align="center">类型</th>
<th align="center">核心思想</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">先来先服务 (FCFS)</td>
<td align="center">批处理</td>
<td align="center">按任务到达顺序执行</td>
<td align="center">简单、无饥饿问题</td>
<td align="center">护航效应（长任务阻塞短任务）</td>
<td align="center">早期批处理系统</td>
</tr>
<tr>
<td align="center">时间片轮转 (RR)</td>
<td align="center">交互式</td>
<td align="center">每个任务分配固定时间片（如 10ms），超时后放入队列尾部</td>
<td align="center">公平性高，响应时间可控</td>
<td align="center">时间片设置影响性能（太小增加开销）</td>
<td align="center">通用操作系统（如 Linux 默认）</td>
</tr>
<tr>
<td align="center">多级反馈队列 (MLFQ)</td>
<td align="center">交互式</td>
<td align="center">多级优先级队列，任务根据行为动态升降级（如 I&#x2F;O 密集型升优先级）</td>
<td align="center">平衡响应时间和吞吐量</td>
<td align="center">实现复杂，需调优参数</td>
<td align="center">混合负载（如服务器、桌面 OS）</td>
</tr>
<tr>
<td align="center">完全公平调度 (CFS)</td>
<td align="center">公平共享</td>
<td align="center">按权重（<code>nice</code> 值）分配 CPU，通过红黑树管理任务的虚拟运行时间（<code>vruntime</code>）</td>
<td align="center">高公平性，支持多任务并发</td>
<td align="center">实时任务需额外策略（如 <code>SCHED_FIFO</code>）</td>
<td align="center">Linux 默认调度器</td>
</tr>
<tr>
<td align="center">最早截止时间优先 (EDF)</td>
<td align="center">实时</td>
<td align="center">优先执行截止时间最近的任务</td>
<td align="center">满足硬实时需求，理论最优</td>
<td align="center">需严格的任务时间约束</td>
<td align="center">工业控制、自动驾驶</td>
</tr>
</tbody></table>
<p><strong>调度策略的实现方式</strong>：指 “如何在代码中具体触发调度策略”</p>
<ul>
<li>抢占式任务调度：每隔一段时间，内核会抢占当前运行任务的CPU控制权，并把控制权给另一个任务，触发条件包括：<ul>
<li>时间片用完（如 Linux CFS 的 <code>sched_yield</code>）</li>
<li>更高优先级任务就绪（如实时任务）</li>
<li>中断或系统调用返回时（如时钟中断触发调度）</li>
</ul>
</li>
<li>协作式任务调度：当前运行任务一直拥有CPU控制权，直到它主动放弃，触发条件包括：<ul>
<li>任务显式调用阻塞函数（如 <code>sleep()</code>、<code>pthread_yield()</code>）</li>
<li>任务等待 I&#x2F;O 或同步事件（如锁、信号量）</li>
</ul>
</li>
</ul>
<blockquote>
<p>XV6使用了&#x3D;&#x3D;时间片轮转&#x3D;&#x3D;调度策略，并通过&#x3D;&#x3D;抢占式&#x3D;&#x3D;调度触发</p>
</blockquote>
<p><strong>任务切换的流程</strong>：</p>
<p>每个CPU会定时产生一个定时器中断，从而让一个<strong>用户线程</strong>陷入内核中（由用户线程切换到<strong>内核线程</strong>），让CPU的控制权由用户线程变为内核。在内核线程的中断处理函数中，通过<code>yeild</code>主动让出此CPU给<strong>调度器线程</strong>（每个CPU都有个调度器线程），从而发生调度。此时CPU的控制权会先变到另一个内核线程，再变到该内核线程对应的用户线程</p>
<p><img src="../assets/image-20241107171208903.png" alt="image-20241107171208903"></p>
<ul>
<li>trampframe：保存用户线程CPU的寄存器</li>
<li>context：保存内核线程CPU的寄存器</li>
</ul>
<h3 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h3><p>用户态与内核中使用睡眠函数的区别：</p>
<ul>
<li>用户态：让一个线程睡眠后，可以不手动唤醒，比如在使用<code>sleep(int time)</code>时让线程睡眠指定的一段时间，时间到了后OS会自动唤醒一个线程。但是当使用条件变量而让线程睡眠时<code>pthread_cond_wait</code>，在条件满足时，需要手动唤醒睡眠的线程<code>pthread_cond_signal</code></li>
<li>内核态：让一个线程睡眠<code>sleep()</code>后，必须手动唤醒<code>wakeup()</code></li>
</ul>
<h3 id="进程的退出和资源回收"><a href="#进程的退出和资源回收" class="headerlink" title="进程的退出和资源回收"></a>进程的退出和资源回收</h3><ul>
<li>手动结束一个进程的方法：使用<code>exit()</code>系统调用</li>
<li>普通结束的方法：<code>main()</code>函数的<code>return 0</code></li>
</ul>
<blockquote>
<p>无论子进程是通过 <code>exit</code> 退出，还是通过 <code>return</code> 退出 <code>main</code> 函数，都会最终调用内核的 <code>_exit</code> 函数以结束进程</p>
</blockquote>
<p>注意，任何一个进程都属于一个父进程，当子进程退出时，它自己不会释放资源，并变为<code>Zombie</code>状态，需要父进程调用<code>wait()</code>系统调用，来回收子进程的资源</p>
<ul>
<li><code>wait()</code>系统调用有点类似C++11线程库的<code>join()</code>，用于阻塞等待子进程的退出，并回收其资源</li>
</ul>
<p><strong>僵尸进程</strong>：已经终止运行但还未被父进程回收的进程</p>
<p>如果一个进程结束前它的父进程就结束了，父进程在结束前会把它的子进程的所有权转给<code>init</code>进程，由它帮忙回收子进程的资源</p>
<h2 id="8-进程间通信-同步-互斥"><a href="#8-进程间通信-同步-互斥" class="headerlink" title="8.进程间通信&#x2F;同步&#x2F;互斥"></a>8.进程间通信&#x2F;同步&#x2F;互斥</h2><h3 id="概念的区别"><a href="#概念的区别" class="headerlink" title="概念的区别"></a>概念的区别</h3><table>
<thead>
<tr>
<th align="center">概念</th>
<th align="center">核心目标</th>
<th align="center">典型场景</th>
<th align="center">实现方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通信</td>
<td align="center">进程间数据交换</td>
<td align="center">传递消息或共享数据（如管道、共享内存）</td>
<td align="center">管道、消息队列、共享内存、Socket等</td>
</tr>
<tr>
<td align="center">同步</td>
<td align="center">协调进程的执行顺序</td>
<td align="center">确保某些操作按特定顺序执行（如A完成后B再执行）</td>
<td align="center">信号量、条件变量、屏障（Barrier）等</td>
</tr>
<tr>
<td align="center">互斥</td>
<td align="center">保护共享资源，避免并发访问冲突</td>
<td align="center">临界区（如共享文件、内存的原子操作）</td>
<td align="center">互斥锁、信号量（二元信号量）、自旋锁等</td>
</tr>
</tbody></table>
<p>同步和互斥的区别：举“生产者-消费者”的例子，如果同时存在多个生产者线程同时往buffer中写数据，则属于<strong>互斥</strong>问题；当缓冲区为空的时候，需要生产者先往buffer中写数据，消费者才能读数据，属于<strong>同步</strong>问题</p>
<h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ul>
<li>互斥是同步的一种特例：互斥通过限制共享资源的访问顺序实现同步，属于同步的子集</li>
<li>进程间的通信可能<strong>依赖</strong>同步&#x2F;互斥机制：例如，共享内存通信需要互斥机制（如锁）保护数据一致性；消息队列本身可能内置同步（阻塞发送&#x2F;接收）</li>
<li>同步&#x2F;互斥的实现<strong>依赖</strong>底层通信：某些同步机制（如信号量）可能通过内核提供的IPC机制实现</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>定义：两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象</p>
<p>出现场景：</p>
<p>1.一个线程中在未释放的情况下多次请求同一个锁</p>
<p>2.由获取锁的顺序导致死锁：线程1需要依次获取锁A和B，线程2需要依次获取锁B和A，这会导致死锁</p>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>按锁的实现原理分类：</p>
<p>(1) 互斥锁(睡眠锁)</p>
<ul>
<li>特点：最基本的锁，保证同一时间只有一个线程能进入临界区</li>
<li>行为：未获取锁的线程会被阻塞（进入休眠状态）</li>
<li>示例：<code>pthread_mutex_t</code>（POSIX）、<code>std::mutex</code>（C++）</li>
</ul>
<p>(2) 自旋锁</p>
<ul>
<li>特点：通过循环忙等待（Busy-Waiting）尝试获取锁，而非阻塞线程</li>
<li>适用场景：临界区非常小且线程阻塞代价较高（如内核态代码）</li>
<li>缺点：浪费CPU资源</li>
<li>示例：<code>pthread_spinlock_t</code>、<code>std::atomic_flag</code>（C++自旋锁实现）</li>
</ul>
<p>(3) 读写锁</p>
<ul>
<li>特点：区分读锁（共享）和写锁（独占），提高<strong>读多写少</strong>场景的性能<ul>
<li>读锁：允许多个线程同时读</li>
<li>写锁：只允许一个线程写，且与读锁互斥</li>
</ul>
</li>
</ul>
<h3 id="自旋锁的实现"><a href="#自旋锁的实现" class="headerlink" title="自旋锁的实现"></a>自旋锁的实现</h3><p>一般人可能一下子就想到了用这种<strong>错误</strong>的方式实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    <span class="keyword">if</span>(lk-&gt;locked == <span class="number">0</span>) &#123;</span><br><span class="line">        lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现在获得锁的时候还是会存在<strong>竞争</strong>，比如2个CPU可能会同时拿到锁（本质上因为CPU的<code>load</code>和<code>store</code>指令是非原子的）因此在判断能不能拿到锁的时候，应该<strong>原子操作</strong>指令</p>
<p>在XV6中它的锁的实现是靠<a target="_blank" rel="noopener" href="https://www.cnblogs.com/upnote/p/13193856.html">TAS</a>这个原子操作来实现的，并且还需要考虑<strong>内存顺序</strong>的问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>); <span class="comment">//test and set操作</span></span><br><span class="line">  __sync_synchronize();<span class="comment">//同步内存序</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>原子操作属于ISA提供的CPU指令，对于RISC-V来说，A指令集模块提供了一些原子操作指令。C++标准库的锁、原子变量的底层实现都依赖这些指令。如果所使用的内核不带A指令集，那他就没办法使用这些同步机制了</p>
<p><strong>常见的原子操作</strong>如下：</p>
<ul>
<li>CAS（Compare-And-Swap）比较内存值和预期值，如果相等则更新为新值，否则失败</li>
<li>TAS（Test-And-Set）读取内存值并强制设置为新值（通常用于锁标志）返回旧值</li>
<li>FAA（Fetch-And-Add）原子地读取内存值并增加一个数值，返回旧值</li>
</ul>
<h4 id="内存顺序"><a href="#内存顺序" class="headerlink" title="内存顺序"></a>内存顺序</h4><p>现代 CPU 和编译器会对指令进行<strong>乱序执行</strong>以提高性能，但在多线程环境下，这可能导致<strong>数据不一致</strong>。<br>内存顺序用于控制这种乱序行为，确保线程间的数据同步</p>
<p>CPU底层通常会提供一些“内存屏障”指令，用来控制指令执行顺序和内存访问的可见性，RISC-V 提供了 <code>FENCE</code> 指令，用于控制内存访问顺序，语法如下：</p>
<figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FENCE pred, succ</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pred</code>（前驱操作）：可以是 <code>R</code>（Read）、<code>W</code>（Write）、<code>RW</code>（Read+Write）</li>
<li><code>succ</code>（后继操作）：同上，表示 <code>FENCE</code> 之后的操作必须等待前面的操作完成</li>
</ul>
<p><strong>内存屏障的应用</strong>：</p>
<p>(1)锁的底层实现：</p>
<ul>
<li>加锁（Lock）：确保临界区内的操作不会被重排序到加锁之前</li>
<li>解锁（Unlock）：确保临界区内的操作不会被重排序到解锁之后</li>
</ul>
<p>(2)无锁编程：如果临界区极短、追求极致性能时，可以使用内存屏障来实现临界区的互斥访问，并不需要用锁</p>
<h3 id="无锁同步机制"><a href="#无锁同步机制" class="headerlink" title="无锁同步机制"></a>无锁同步机制</h3><h4 id="RCU"><a href="#RCU" class="headerlink" title="RCU"></a>RCU</h4><p>RCU（Read-Copy-Update）是一种<strong>不需要锁</strong>的同步机制，主要用于解决多线程环境中<strong>读多写少</strong>场景下的性能问题。它通过<strong>无锁读取</strong>和<strong>延迟更新</strong>显著提升并发效率，核心思想：</p>
<ul>
<li>读者无锁访问：读取数据时无需加锁，直接访问共享资源，保证高性能，但在临界区内需要禁止调度</li>
<li>写者延迟更新：写入时先创建数据的副本，修改副本后通过<strong>原子操作</strong>替换原数据，并通过内存屏障机制（<code>synchronize_rcu</code>）等待所有旧读者退出后再回收旧数据</li>
</ul>
<blockquote>
<p>虽然RCU和读写锁都用于“读多写少”的场景，但是RCU的读写不互斥，且读写锁底层要解决缓存一致性问题，效率比较低</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">场景</th>
<th align="center">RCU</th>
<th align="center">传统锁（如互斥锁）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读者</td>
<td align="center">无锁，直接访问</td>
<td align="center">需加锁，可能阻塞或被阻塞</td>
</tr>
<tr>
<td align="center">写者</td>
<td align="center">无锁发布数据，宽限期异步回收</td>
<td align="center">需独占锁，阻塞其他读写者</td>
</tr>
<tr>
<td align="center">并发性</td>
<td align="center">读者与读者、读者与写者完全并发</td>
<td align="center">读写互斥，串行化访问</td>
</tr>
</tbody></table>
<p>RCU的缺点：</p>
<ul>
<li>无法保证读&#x2F;写数据完全同步，在<code>synchronize_rcu</code>前进入临界区的读者会读到旧数据</li>
<li>若多个写者并发修改同一数据，仍需外部锁（如自旋锁），这会部分抵消 RCU 的优势</li>
</ul>
<h2 id="9-文件系统"><a href="#9-文件系统" class="headerlink" title="9.文件系统"></a>9.文件系统</h2><p>文件系统目的：将所有数据结构以一种能够在重启之后重新构建文件系统的方式，存放在磁盘上。不同的文件系统在磁盘上的布局不同</p>
<h3 id="磁盘读写粒度"><a href="#磁盘读写粒度" class="headerlink" title="磁盘读写粒度"></a>磁盘读写粒度</h3><ul>
<li>Sector：磁盘<strong>硬件</strong>的最小读写单元，通常为512B</li>
<li>Block：<strong>文件系统</strong>管理磁盘的最小逻辑单元，通常为4KB(与内存页对齐)，XV6中是1024 B</li>
</ul>
<h3 id="XV6文件系统的分层"><a href="#XV6文件系统的分层" class="headerlink" title="XV6文件系统的分层"></a>XV6文件系统的分层</h3><ul>
<li>在最底层是磁盘，也就是一些实际保存数据的存储设备，正是这些设备提供了持久化存储</li>
<li>在这之上是buffer cache或者说block cache，这些cache可以避免频繁的读写磁盘。这里我们将磁盘中的数据保存在了内存中</li>
<li>为了保证持久性，再往上通常会有一个logging层。许多文件系统都有某种形式的logging</li>
<li>在logging层之上，XV6有inode cache，这主要是为了同步（synchronization）inode通常小于一个disk block，所以多个inode通常会打包存储在一个disk block中。为了向单个inode提供同步操作，XV6维护了inode cache</li>
<li>再往上就是inode本身了。它实现了read&#x2F;write</li>
<li>再往上，就是文件名，和文件描述符操作</li>
</ul>
<h3 id="磁盘布局"><a href="#磁盘布局" class="headerlink" title="磁盘布局"></a>磁盘布局</h3><p>XV6文件系统在磁盘上以如下的方式布局：</p>
<img src="../assets/image-20250602160814773.png" alt="image-20250602160814773" style="zoom:80%;" />

<ul>
<li>block0要么没有用，要么被用作boot sector来启动操作系统</li>
<li>block1：super block，它描述了文件系统。它可能包含磁盘上有多少个block共同构成了文件系统这样的信息。我们之后会看到XV6在里面会存更多的信息，你可以通过block1构造出大部分的文件系统信息</li>
<li>block2~block32：存log信息。实际上log的大小可能不同，这里在super block中会定义log就是30个block</li>
<li>block32~block45：存储inode。多个inode会打包存在一个block中，一个inode是64字节，即一个block只能存16个inode，XV6最多能存16*14&#x3D;224个文件&#x2F;目录</li>
<li>bitmap block：只占据一个block。它记录了各个数据block是否空闲</li>
<li>数据block：存储文件的内容和目录的内容</li>
</ul>
<blockquote>
<p>通常来说，bitmap block，inode blocks和log blocks被统称为metadata block。它们虽然不存储实际的数据，但是它们存储了能帮助文件系统完成工作的元数据</p>
</blockquote>
<h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p>inode是所有文件系统都会有的一个数据结构，他记录了磁盘中某个文件的一些属性信息。XV6中的inode的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>inode不仅会在内存中，他本身也会存在磁盘中！并且在不同位置时包含的字段还不一样</p>
<p>关键字段：</p>
<ul>
<li>type：表明inode是文件还是目录。</li>
<li>nlink：也就是link计数器，用来跟踪究竟有多少文件名指向了当前的inode。</li>
<li>size：表明了文件数据有多少个字节。</li>
<li>addrs：一个数组，存了inode对应文件的各个磁盘block的编号（XV6中每个inode有12个direct block和256个indirect block，所以一个文件最大占268*1024字节）</li>
</ul>
<blockquote>
<p>有了inode其实就可以实现<code>read</code>&#x2F;<code>write</code>系统调用了</p>
</blockquote>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>目录也是一种文件，他的数据部分包含了多个&#x3D;&#x3D;目录项&#x3D;&#x3D;（direct entry）数据结构。XV6中每一个目录项的组成如下：</p>
<ul>
<li>前2个字节包含了目录中文件或者子目录的inode编号</li>
<li>接下来的14个字节包含了该目录项对应的文件或者子目录的名字</li>
</ul>
<blockquote>
<p>有了目录，OS就能实现<strong>结构化命名</strong>和根据文件名<strong>查找</strong>文件了，原理其实就是从根目录开始查找所有目录项的name字段，看看是否匹配</p>
</blockquote>
<h3 id="文件系统镜像"><a href="#文件系统镜像" class="headerlink" title="文件系统镜像"></a>文件系统镜像</h3><p>XV6的文件系统实际上是挂载的<code>fs.img</code>这个文件，而每次<code>make qemu</code>时，都会由<code>mkfs</code>这个可执行文件重新构建<code>fs.img</code>。它的布局就跟上面说的一样</p>
<p><img src="../assets/image-20250602170004611.png" alt="image-20250602170004611"></p>
<h3 id="BufferCache"><a href="#BufferCache" class="headerlink" title="BufferCache"></a>BufferCache</h3><p>之前看Linux源码解析的时候，发现OS里面居然有cache部分还很有疑问，一直以为cache只存在于CPU硬件中，实际上OS里确实会有cache，这部分cache用于把<strong>磁盘</strong>的东西缓存到内存里面。而基于缓存的粒度，对磁盘的缓存可以分为：</p>
<ul>
<li>buffer cache：对磁盘块缓存（XV6只有这种）</li>
<li>page cache：对文件进行缓存（以page为单位）</li>
</ul>
<p>当第一次对磁盘进行IO操作读数据的时候，回把从磁盘读到的数据存到OS的cache（内存）里，后续再对磁盘进行IO操作时，首先会看cache里有没有缓存对应的块，有的话就只会操作这个cache，最后结束对此块的IO操作时，再把cache里的数据flush回磁盘，其实跟CPU里的cache如出一辙</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://Li-Ruiqi777.github.io">Li Ruiqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://li-ruiqi777.github.io/07-RISC-V/XV6.html">https://li-ruiqi777.github.io/07-RISC-V/XV6.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/07-RISC-V/XV6%E5%AE%9E%E9%AA%8C.html" title="XV6实验"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">XV6实验</div></div><div class="info-2"><div class="info-item-1">XV6 Labs参考 Mit6.S081学习记录-CSDN博客  Lab Utils  Slepp实验：写一个用户程序，调用sleep system call实现，执行sleep 10，表示程序等待10个时钟周期  pingpong实验：写一个程序，使用unix system calls在两个进程间”ping-pong“一个字节，使用一对pipe，一个pipe对应一个方向，另外一个pipe对应另外一个方向  find实验：实现find用户程序 ，即在某个路径中，找出某个文件  xargs实验：实现类似unix xargs类似功能，比如echo hello too|xargs echo bye，要输出bye hello too  Lab System Calls  System call tracing实验：实现trace系统调用，跟踪指定的系统调用  Sysinfo实验：实现一个sysinfo 系统调用，可以实现打印当前空闲内存大小(字节)、可用进程数  Lab Page tables  Print a page...</div></div></div></a><a class="pagination-related" href="/06-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E6%80%BB%E7%BB%93.html" title="半导体器件总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">半导体器件总结</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Li Ruiqi</div><div class="author-info-description">总有低谷</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">143</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Li-Ruiqi777"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Li-Ruiqi777" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1009962019@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#XV6"><span class="toc-number">1.</span> <span class="toc-text">XV6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%B0%83%E8%AF%95"><span class="toc-number">1.1.</span> <span class="toc-text">1.调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-RISC-V-ISA"><span class="toc-number">1.2.</span> <span class="toc-text">2.RISC-V ISA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.1.</span> <span class="toc-text">参考链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%9D%83%E7%AD%89%E7%BA%A7"><span class="toc-number">1.2.2.</span> <span class="toc-text">特权等级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.3.</span> <span class="toc-text">常见指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">特权指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B4%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">基础整数寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">浮点寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">状态控制寄存器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-RISC-V-ABI"><span class="toc-number">1.3.</span> <span class="toc-text">3.RISC-V ABI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">函数调用约定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%9D%E5%AD%98"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">上下文保存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="toc-number">1.3.2.</span> <span class="toc-text">系统调用约定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E9%BD%90"><span class="toc-number">1.3.3.</span> <span class="toc-text">数据布局与对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-1"><span class="toc-number">1.3.4.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Trap"><span class="toc-number">1.4.</span> <span class="toc-text">4.Trap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.2.</span> <span class="toc-text">触发场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">相关寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trap%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">Trap的处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.5.</span> <span class="toc-text">新增系统调用的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E4%B8%AA%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%A1%B5%E8%A1%A8%E4%B8%AD%E9%83%BD%E8%A6%81%E6%98%A0%E5%B0%84trampoline%E5%92%8Ctrapframe"><span class="toc-number">1.4.6.</span> <span class="toc-text">为什么每个用户进程的页表中都要映射trampoline和trapframe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trap%E6%97%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.4.7.</span> <span class="toc-text">Trap时如何保存上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.8.</span> <span class="toc-text">系统调用如何传递参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XV6%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.9.</span> <span class="toc-text">XV6处理异常的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-2"><span class="toc-number">1.4.10.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">5.中断管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E7%BC%96%E7%A8%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">如何对硬件设备编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">中断相关的寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E8%B7%AF%E7%94%B1"><span class="toc-number">1.5.3.</span> <span class="toc-text">中断的路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%AA%E9%A2%91%E7%B9%81%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">1.5.4.</span> <span class="toc-text">中断太频繁怎么办</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">6.内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%A1%AC%E4%BB%B6"><span class="toc-number">1.6.1.</span> <span class="toc-text">相关硬件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.6.2.</span> <span class="toc-text">内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RISC-V%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">RISC-V地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">内核空间内存布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">用户进程内存布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.3.</span> <span class="toc-text">页表与地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RISC-V%E7%9A%84%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">RISC-V的分页机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">虚拟地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">物理地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PTE%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">PTE结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%BC%93%E5%AD%98-TLB"><span class="toc-number">1.6.4.</span> <span class="toc-text">页表缓存(TLB)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Page-Fault"><span class="toc-number">1.6.5.</span> <span class="toc-text">Page Fault</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Copy-On-Write-fork"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">Copy On Write fork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sbrk"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">sbrk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lazy-Allocation"><span class="toc-number">1.6.5.4.</span> <span class="toc-text">Lazy Allocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Demand-Paging"><span class="toc-number">1.6.5.5.</span> <span class="toc-text">Demand Paging</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="toc-number">1.6.5.6.</span> <span class="toc-text">页面置换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory-Mapped-Files"><span class="toc-number">1.6.5.7.</span> <span class="toc-text">Memory Mapped Files</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">1.6.6.</span> <span class="toc-text">物理内存的分配与回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XV6%E4%B8%AD%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.7.</span> <span class="toc-text">XV6中内存相关的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">1.6.7.1.</span> <span class="toc-text">物理内存分配与回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">1.6.7.2.</span> <span class="toc-text">虚拟内存映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-3"><span class="toc-number">1.6.8.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">7.进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">任务模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.7.2.</span> <span class="toc-text">任务的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">1.7.3.</span> <span class="toc-text">任务调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%A1%E7%9C%A0%E4%B8%8E%E5%94%A4%E9%86%92"><span class="toc-number">1.7.4.</span> <span class="toc-text">睡眠与唤醒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BA%E5%92%8C%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6"><span class="toc-number">1.7.5.</span> <span class="toc-text">进程的退出和资源回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E5%90%8C%E6%AD%A5-%E4%BA%92%E6%96%A5"><span class="toc-number">1.8.</span> <span class="toc-text">8.进程间通信&#x2F;同步&#x2F;互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.1.</span> <span class="toc-text">概念的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E7%B3%BB"><span class="toc-number">1.8.2.</span> <span class="toc-text">联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.8.3.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.8.4.</span> <span class="toc-text">锁的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.8.5.</span> <span class="toc-text">自旋锁的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">原子操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">内存顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.6.</span> <span class="toc-text">无锁同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RCU"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">RCU</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9.文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E7%B2%92%E5%BA%A6"><span class="toc-number">1.9.1.</span> <span class="toc-text">磁盘读写粒度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XV6%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E5%B1%82"><span class="toc-number">1.9.2.</span> <span class="toc-text">XV6文件系统的分层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.9.3.</span> <span class="toc-text">磁盘布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inode"><span class="toc-number">1.9.4.</span> <span class="toc-text">inode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.9.5.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F"><span class="toc-number">1.9.6.</span> <span class="toc-text">文件系统镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BufferCache"><span class="toc-number">1.9.7.</span> <span class="toc-text">BufferCache</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Li Ruiqi</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">人因梦想而伟大</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
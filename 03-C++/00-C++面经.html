<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>00 C++面经 | 李瑞琦的博客</title><meta name="author" content="Li Ruiqi"><meta name="copyright" content="Li Ruiqi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="C&#x2F;C++八股关键字static1.static的作用是什么  在函数体内 + 修饰局部变量：其访问权限在函数内，仅初始化一次，存储于静态存储区 在函数体外 + 修饰全局变量：将模块的全局变量限制在模块内部（仅供.c使用），不能跨文件共享  修饰函数：该函数仅可被本模块调用，不能作为接口暴露给其他模块  注意：static 与 extern不可同时修饰一个变量 2.static结合函数重">
<meta property="og:type" content="article">
<meta property="og:title" content="00 C++面经">
<meta property="og:url" content="https://li-ruiqi777.github.io/03-C++/00-C++%E9%9D%A2%E7%BB%8F.html">
<meta property="og:site_name" content="李瑞琦的博客">
<meta property="og:description" content="C&#x2F;C++八股关键字static1.static的作用是什么  在函数体内 + 修饰局部变量：其访问权限在函数内，仅初始化一次，存储于静态存储区 在函数体外 + 修饰全局变量：将模块的全局变量限制在模块内部（仅供.c使用），不能跨文件共享  修饰函数：该函数仅可被本模块调用，不能作为接口暴露给其他模块  注意：static 与 extern不可同时修饰一个变量 2.static结合函数重">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://li-ruiqi777.github.io/img/head.png">
<meta property="article:published_time" content="2025-09-26T01:24:16.638Z">
<meta property="article:modified_time" content="2025-09-26T01:34:49.708Z">
<meta property="article:author" content="Li Ruiqi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://li-ruiqi777.github.io/img/head.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://li-ruiqi777.github.io/03-C++/00-C++%E9%9D%A2%E7%BB%8F.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '00 C++面经',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.7.0/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/jetbrains-mono@4.5.12/index.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(135deg, #a9d6e0 0%, #e0f7fa 100%);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">19</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">李瑞琦的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">00 C++面经</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">00 C++面经</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-09-26T01:24:16.638Z" title="Created 2025-09-26 09:24:16">2025-09-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-09-26T01:34:49.708Z" title="Updated 2025-09-26 09:34:49">2025-09-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/03-C/">03-C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C-C-八股"><a href="#C-C-八股" class="headerlink" title="C&#x2F;C++八股"></a>C&#x2F;C++八股</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>1.static的作用是什么</p>
<ul>
<li>在函数体内 + 修饰局部变量：其访问权限在函数内，仅初始化一次，存储于静态存储区</li>
<li>在函数体外 + 修饰全局变量：将模块的全局变量限制在模块内部（仅供.c使用），不能跨文件共享 </li>
<li>修饰函数：该函数仅可被本模块调用，不能作为接口暴露给其他模块</li>
</ul>
<p>注意：static 与 extern不可同时修饰一个变量</p>
<p>2.static结合函数重入性的理解</p>
<blockquote>
<p>可重入函数：函数可以被多个任务&#x2F;线程同时调用而不会产生错误结果</p>
</blockquote>
<ul>
<li>static会引入状态持久性和共享状态，这与可重入函数所需的无状态和独立性要求直接<strong>冲突</strong></li>
</ul>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>1.define和const区别，分别什么时候生效</p>
<ul>
<li><code>#define</code>（宏定义）<ul>
<li><strong>预处理阶段</strong>生效，由预处理器进行简单的文本替换，不占用内存</li>
<li>无类型检查，可能导致意外错误（如 <code>#define PI 3.14</code> 替换后可能产生表达式问题）</li>
<li>作用域：从定义处到文件末尾（或 <code>#undef</code>）</li>
</ul>
</li>
<li><code>const</code>（常量）<ul>
<li><strong>编译阶段</strong>生效，是类型安全的变量，占用内存（通常存储在只读数据段）</li>
<li>编译器会检查类型，避免错误</li>
<li>作用域：遵循变量作用域规则（如局部 <code>const</code> 只在函数内有效）</li>
</ul>
</li>
</ul>
<p>何时使用？</p>
<ul>
<li>用 <code>#define</code>：需要全局替换、条件编译（如 <code>#ifdef DEBUG</code>）或定义无类型常量（如数组大小）</li>
<li>用 <code>const</code>：需要类型安全、调试时可查看符号、或涉及指针&#x2F;引用时（如 <code>const int* p</code>）</li>
</ul>
<p>2.<code>char const* p</code>有什么特点？地址变吗？</p>
<blockquote>
<p>区分“指针常量“与”常量指针“：<code>*</code> (指针)和 <code>const</code>（常量） 谁在前先读谁 ；<code>*</code>象征着地址，const象征着内容；<strong>谁在前面谁就不允许改变</strong></p>
</blockquote>
<ul>
<li>char const* p属于常量指针，<code>p</code>指向的地址可以变，但是地址的值不能变</li>
</ul>
<h3 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h3><p>1.define宏为什么要加括号？</p>
<ul>
<li>避免运算符优先级导致的错误</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) x * x      <span class="comment">// 错误写法</span></span></span><br><span class="line"><span class="type">int</span> a = SQUARE(<span class="number">1</span> + <span class="number">2</span>);       <span class="comment">// 替换为 1 + 2 * 1 + 2 = 5（非预期）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) (x) * (x)  <span class="comment">// 正确写法</span></span></span><br><span class="line"><span class="type">int</span> a = SQUARE(<span class="number">1</span> + <span class="number">2</span>);       <span class="comment">// 替换为 (1 + 2) * (1 + 2) = 9</span></span><br></pre></td></tr></table></figure>

<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p>1.结构体和联合体的区别？</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">结构体（struct）</th>
<th align="center">联合体（union）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内存布局</td>
<td align="center">成员独立存储，占用总大小为各成员之和（对齐后）</td>
<td align="center">成员共享内存，大小为最大成员的大小</td>
</tr>
<tr>
<td align="center">访问方式</td>
<td align="center">所有成员可同时访问</td>
<td align="center">同一时间只能使用一个成员</td>
</tr>
<tr>
<td align="center">用途</td>
<td align="center">存储逻辑相关的多个数据（如坐标点 <code>&#123;x, y&#125;</code>）</td>
<td align="center">节省内存，表示互斥数据（如类型转换）</td>
</tr>
<tr>
<td align="center">示例</td>
<td align="center"><code>struct &#123; int x; float y; &#125;;</code></td>
<td align="center"><code>union &#123; int i; float f; &#125;;</code></td>
</tr>
</tbody></table>
<p>2.和<code>bitfield</code>的区别：<code>union</code>是所有成员共用一块内存，而位段的每个成员是独立的，他是把一个结构体的内存分成多份</p>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>1.define和typedef的区别？</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">#define</th>
<th align="center">typedef</th>
</tr>
</thead>
<tbody><tr>
<td align="center">阶段</td>
<td align="center">预处理阶段（文本替换）</td>
<td align="center">编译阶段（类型别名）</td>
</tr>
<tr>
<td align="center">类型安全</td>
<td align="center">无类型检查，可能出错</td>
<td align="center">有类型检查，更安全</td>
</tr>
<tr>
<td align="center">作用域</td>
<td align="center">文件作用域（可 <code>#undef</code>）</td>
<td align="center">遵循变量作用域规则</td>
</tr>
<tr>
<td align="center">复杂声明</td>
<td align="center">需谨慎处理（如指针类型）</td>
<td align="center">适合定义复杂类型（如函数指针）</td>
</tr>
<tr>
<td align="center">示例</td>
<td align="center"><code>#define INT_P int*</code>（易误用）</td>
<td align="center"><code>typedef int* INT_P;</code>（明确类型）</td>
</tr>
</tbody></table>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>1.volatile的作用是什么</p>
<ul>
<li><p>作用：被修饰的变量每次都从内存或对应外设寄存器中重新取值放入CPU寄存器通用寄存器后再进行操作，防止<strong>编译器</strong>优化（编译器可能&#x3D;&#x3D;合并&#x3D;&#x3D;多个连续地对同一个变量的读操作，它其实暗含了同一个变量可能被多个线程修改）</p>
</li>
<li><p>详解：CPU读取数据时，会从指定地址处取值并搬运到CPU通用寄存器中处理，在不加volatile时，对于频繁的操作，编译器会将代码的汇编指令进行优化，例子如下：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如要往某一地址送两指令： </span></span><br><span class="line"><span class="type">int</span> *ip = <span class="number">0x12345678</span>; <span class="comment">//设备地址 </span></span><br><span class="line">*ip = <span class="number">1</span>; <span class="comment">//第一个指令 </span></span><br><span class="line">*ip = <span class="number">2</span>; <span class="comment">//第二个指令</span></span><br><span class="line"><span class="comment">// 编译器可能优化为：</span></span><br><span class="line"><span class="type">int</span> *ip = <span class="number">0x12345678</span>; <span class="comment">//设备地址 </span></span><br><span class="line">*ip = <span class="number">2</span>; <span class="comment">//第二个指令</span></span><br><span class="line"><span class="comment">// 造成第一条指令被忽略</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> *ip = <span class="number">0x12345678</span>; <span class="comment">//设备地址 </span></span><br><span class="line">*ip = <span class="number">1</span>; <span class="comment">//第一个指令 </span></span><br><span class="line">*ip = <span class="number">2</span>; <span class="comment">//第二个指令</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用场合：寄存器、临界区访问的变量、中断函数访问的全局或static变量</p>
</li>
<li><p>Note：与Cache的区别： </p>
<ul>
<li>volatile是&#x3D;&#x3D;对编译器&#x3D;&#x3D;的约束，不会删掉从RAM读取到通用寄存器的指令，但无法控制从RAM到通用寄存器的具体行为（从RAM到寄存器要经过cache）。若两次被volatile修饰的读取指令过快，即使RAM中的值改变了，但由于读取过快没有更新cache，那么实际上搬运到通用寄存器的值来自于cache，此类情况下需要禁用cache。</li>
<li>编译器优化是针对于<code>ld</code>命令的，从内存中读取数据到寄存器时不允许优化这一过程，而None cache保护的是对内存数据的访问（volatile无法控制<code>ld</code>命令执行后是否刷新cache）</li>
</ul>
</li>
</ul>
<p>2.<code>const</code> 和 <code>volatile</code>可以一起修饰一个变量吗</p>
<ul>
<li>可以的，表达的语义是：我（应用层代码）不允许去写这个变量，但它的值随时可变</li>
<li>典型应用是<strong>硬件只读寄存器</strong>：代码不能写，但硬件可能会更新，比如状态寄存器</li>
</ul>
<h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><ul>
<li>建议编译器将变量存储在CPU寄存器中，以加快访问速度（因为寄存器比内存访问快得多）</li>
<li>此关键字在C++17中被移除</li>
</ul>
<h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p>1.inline的作用是什么</p>
<ul>
<li>此关键字会给编译器提个<strong>建议</strong>，将函数体的代码直接“复制粘贴”到每一个调用它的地方，从而完全避免了函数调用的开销。并不是用了<code>inline</code>就一定会被展开，取决于编译器</li>
<li>函数调用的流程，参数的入&#x2F;出栈是比较耗时的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.执行call指令，跳转到函数地址</span><br><span class="line">2.压入返回地址、保存寄存器（现场保护）</span><br><span class="line">3.在栈上为函数局部变量分配空间</span><br><span class="line">4.执行函数体</span><br><span class="line">5.清理栈空间、恢复寄存器</span><br><span class="line">6.执行ret指令，跳回调用处</span><br></pre></td></tr></table></figure>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>嵌入式笔试貌似经常让手撕字符串相关的（库）函数，而我却不记得C语言怎么用字符串了…现在总结一下</p>
<p>1.创建字符串</p>
<blockquote>
<p>所有字符串都是以<code>&#39;\0&#39;</code>（<strong>结束符</strong>）结尾的，即使创建的时候没有添加，编译器会自动加上的，且占1个字节</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：字符数组</span></span><br><span class="line"><span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="comment">// 方式2：不指定长度</span></span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="comment">// 方式3：逐个字符初始化</span></span><br><span class="line"><span class="type">char</span> str3[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">// 方式4：字符指针</span></span><br><span class="line"><span class="type">char</span> *str4 = <span class="string">&quot;Hello, World!&quot;</span>;  <span class="comment">// 字符串常量，不可修改</span></span><br></pre></td></tr></table></figure>

<p>2.常见库函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 计算字符串的长度(不计算&#x27;\0&#x27;)</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>; </span><br><span class="line"><span class="comment">// 字符串复制(和memcpy很像，从第0个字节开始对dest覆盖，但此函数遇到&#x27;\0&#x27;自动停止)</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 字符串拼接</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 字符串转数字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">atof</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">atol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">// 按位比较大小（返回0表示完全相等，不相等的话返回第一个不相等的字符的ASCII码差值）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以<code>char*</code>为返回值的，<code>char*</code>其实是个指向<code>dest</code>的指针，之所以搞成这样是历史遗留问题</p>
</blockquote>
<h3 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h3><p>1.<code>char s[]=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;</code>和<code>char *s=&quot;abc&quot;</code>有什么区别</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>char s[] = &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;;</code></th>
<th align="left"><code>char *s = &quot;abc&quot;;</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left">类型</td>
<td align="left">字符数组</td>
<td align="left">指针（指向字符串字面量）</td>
</tr>
<tr>
<td align="left">内存区域</td>
<td align="left">栈&#x2F;.data（取决于是局部还是全局变量）</td>
<td align="left">s存在栈，而”abc”存在.rodata</td>
</tr>
<tr>
<td align="left">结尾是否有 <code>&#39;\0&#39;</code></td>
<td align="left">无</td>
<td align="left">自动添加</td>
</tr>
<tr>
<td align="left">能否修改内容</td>
<td align="left">能</td>
<td align="left">不能</td>
</tr>
<tr>
<td align="left"><code>sizeof</code>结果</td>
<td align="left">数组大小（3）</td>
<td align="left">指针大小（4或8）</td>
</tr>
<tr>
<td align="left"><code>strlen</code>结果</td>
<td align="left">崩溃</td>
<td align="left">3</td>
</tr>
</tbody></table>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>嵌入式笔试貌似经常让手撕内存相关的（库）函数，而我却基本忘完了…现在总结一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配指定字节数的未初始化内存</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">// 分配指定数量和大小的内存，并初始化为0</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">// 调整已分配内存块的大小(可能原地操作，也可能换个位置操作)</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">realloc</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> new_size)</span>;</span><br><span class="line"><span class="comment">// 释放之前分配的内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* ptr)</span>;</span><br><span class="line"><span class="comment">// 从源内存复制n个字节到目标内存（返回值是dest）</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 安全内存复制，能处理src和dest重叠情况</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">memmove</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 将内存块的前n个字节设置为指定值</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">int</span> value, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 比较两个内存区域的前n个字节</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* ptr1, <span class="type">const</span> <span class="type">void</span>* ptr2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><ul>
<li>目的：为了提升性能。CPU访问内存（比如<code>ld</code>汇编指令）<strong>不是以字节</strong>为单位，而是以<strong>字</strong>为单位（通常是4&#x2F;8字节），字的大小就是所谓的对齐边界<ul>
<li>大多数现代CPU（如x86, ARM）对<strong>对齐的内存访问</strong>做了优化。例如，一个4字节的<code>int</code>变量存储在4的倍数地址上，CPU可以通过一个内存读写操作来完成访问。</li>
<li>如果数据<strong>未对齐</strong>（例如一个<code>int</code>变量起始地址在0x0003），CPU可能需要执行<strong>两次内存访问</strong>（一次取0x0000-0x0003，一次取0x0004-0x0007），然后拼接出所需的数据，这大大降低了效率。</li>
</ul>
</li>
</ul>
<h4 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h4><p>结构体对齐是<strong>编译器</strong>为了实现内存对齐采用的一种策略，他的规则如下：</p>
<ul>
<li><p>成员自身对齐：结构体中的每个成员变量，其<strong>地址</strong>必须是它自身大小（或编译器默认对齐值，取较小者）的<strong>整数倍</strong></p>
<ul>
<li><p><code>char</code>（1字节）： 地址可以是任何值（1的倍数）</p>
</li>
<li><p><code>short</code>（2字节）： 地址必须是2的倍数（0x0, 0x2, 0x4…）</p>
</li>
<li><p><code>int</code>（4字节）： 地址必须是4的倍数（0x0, 0x4, 0x8…）</p>
</li>
<li><p><code>double</code>（8字节）： 地址必须是8的倍数（0x0, 0x8, 0x10…）</p>
</li>
<li><p>指针：在32位系统上是4字节对齐，在64位系统上是8字节对齐</p>
</li>
</ul>
</li>
<li><p>结构体整体对齐：</p>
<ul>
<li>整个结构体的大小，必须是所有成员中最大对齐值（或编译器默认对齐值，取较小者）的整数倍</li>
</ul>
</li>
<li><p>编译器默认对齐值：</p>
<ul>
<li>编译器通常有一个默认的对齐字节数（如8字节），可以通过预编译指令 <code>#pragma pack(n)</code>来修改</li>
</ul>
</li>
</ul>
<p>举点例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Example1</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;   <span class="comment">// 1字节，地址: 0</span></span><br><span class="line">    <span class="type">int</span> b;    <span class="comment">// 4字节，地址必须是4的倍数，不能是1 -&gt; 填充3字节 -&gt; 地址: 4</span></span><br><span class="line">    <span class="type">short</span> c;  <span class="comment">// 2字节，地址: 8 (4+4=8, 是2的倍数)</span></span><br><span class="line">&#125;; <span class="comment">// 总大小目前是 12 字节</span></span><br><span class="line"></span><br><span class="line">Offset: <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>   <span class="number">10</span>  <span class="number">11</span></span><br><span class="line">        |a | . | . | . |b |b |b |b |c |c | . | . |</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用#pragma pack(4)强制改变编译器的默认对齐值</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 4) <span class="comment">// 保存当前对齐值，并设置为4</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Example4</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;     <span class="comment">// 1字节 -&gt; 地址: 0</span></span><br><span class="line">    <span class="type">double</span> d;   <span class="comment">// 8字节，但编译器对齐要求现在是4 -&gt; 地址是4的倍数即可 -&gt; 填充3字节 -&gt; 地址: 4</span></span><br><span class="line">    <span class="type">int</span> b;      <span class="comment">// 4字节 -&gt; 地址: 12 (4+8=12, 是4的倍数)</span></span><br><span class="line">&#125;; <span class="comment">// 目前大小: 0-15 -&gt; 16字节</span></span><br><span class="line">   <span class="comment">// 整体对齐: 必须是min(4, max(1,8,4))=4的倍数 -&gt; 16是4的倍数 -&gt; 总大小: 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop) <span class="comment">// 恢复之前的对齐值</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果修改编译器默认对齐值得话，就会占用24字节</span></span><br></pre></td></tr></table></figure>



<h3 id="类的内存分布"><a href="#类的内存分布" class="headerlink" title="类的内存分布"></a>类的内存分布</h3><p>一个类的内存包含2部分：</p>
<ul>
<li>成员变量</li>
<li>虚函数指针（如果有虚函数的话），占4字节(32位)或8字节(64位)</li>
</ul>
<blockquote>
<p>当有虚函数的时候，类的内存对齐会将每个成员变量填充至8字节</p>
</blockquote>
<h3 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h3><ul>
<li>定义：位段（<code>bit filed</code>）是结构体中的特殊成员，它把一个结构体的内存拆成多份，用于 <strong>按位分配内存</strong>，节省空间</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flag1 : <span class="number">1</span>;  <span class="comment">// 占1位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flag2 : <span class="number">3</span>;  <span class="comment">// 占3位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> padding : <span class="number">4</span>; <span class="comment">// 占4位（对齐用）</span></span><br><span class="line">&#125; bitfield;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用途：</p>
<ul>
<li><p>硬件编程（如操作寄存器特定位）</p>
</li>
<li><p>网络协议（如IP头部的标志位）</p>
</li>
</ul>
</li>
</ul>
<h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><p>在计算机体系结构中，<strong>大小端（Big-Endian &amp; Little-Endian）</strong> 描述的是<strong>多字节数据在内存中的存储顺序</strong>：</p>
<ul>
<li>大端（Big-Endian）：高字节存储在<strong>低地址</strong>，低字节存储在<strong>高地址</strong>（<strong>高位优先</strong>）</li>
<li>小端（Little-Endian）：低字节存储在<strong>低地址</strong>，高字节存储在<strong>高地址</strong>（<strong>低位优先</strong>）</li>
</ul>
<hr>
<h3 id="面试问题-1"><a href="#面试问题-1" class="headerlink" title="面试问题"></a>面试问题</h3><p>1.类实例的内存大小有哪些影响原因</p>
<ul>
<li>非静态成员变量：这是最主要的影响因素。所有非静态成员变量的类型和大小直接相加是基础</li>
<li>内存对齐：为了CPU高效访问内存，编译器会在成员之间插入填充字节（Padding），确保每个成员都从其自身大小整数倍的地址开始。这会导致总大小可能大于所有成员大小之和</li>
<li>虚函数：如果类有虚函数，编译器会为该类自动生成一个虚函数表指针。这个指针通常占用一个机器字长（如32位系统4字节，64位系统8字节）</li>
<li>继承：派生类会包含其所有基类的非静态成员（可能还包括基类的vptr）</li>
<li>空类：一个完全没有成员的空类，其大小通常为1字节。这是为了确保每个实例在内存中都有唯一的地址</li>
</ul>
<p>2.成员对象的顺序会对实例的内存有影响吗</p>
<ul>
<li>有影响，主要是通过内存对齐影响</li>
</ul>
<p>3.成员函数的大小会对实例的内存有影响吗</p>
<ul>
<li>不会，成员函数都存在<code>.text</code>段，并且所有实例共享</li>
</ul>
<p>4.虚函数和static函数对实例的内存有影响吗</p>
<ul>
<li>static函数不会，虚函数会，因为它会让编译器给这个类添加一个新的成员变量（虚函数表指针），这会增大一个指针大小的开销，但是虚函数本身在<code>.text</code>段，无影响</li>
</ul>
<p>5.栈内是保存什么的？malloc出来的地址在栈还是堆？</p>
<ul>
<li>栈保存局部变量、函数传入的参数、函数调用返回地址以及一些CPU寄存器</li>
<li>malloc分配的内存在堆区，但是它返回的指针变量本身是在栈上</li>
</ul>
<p>6.全局变量和静态变量保存在哪里</p>
<ul>
<li>看是否初始化，在<code>.data</code>或者<code>.bss</code></li>
</ul>
<p>7.C语言函数里面如何定义多个名字相同的变量？变量作用域？</p>
<ul>
<li>不能直接定义同名变量，因为C语言在同一作用域内不允许变量重名</li>
<li>但可以通过作用域嵌套（块作用域）实现“同名”变量</li>
</ul>
<p>8.C的函数的入参是存放在哪里？所有入参都是栈吗？</p>
<ul>
<li>以RISCV为例，函数调用的入口参数放在<code>a0</code>~&#96;a7&#96;寄存器，放不下的放到栈里面</li>
</ul>
<p>10.<code>malloc</code>的底层原理</p>
<p><code>malloc</code>是C库的一个函数，它的核心任务是：在用户态的堆空间中，高效地管理一块巨大的虚拟内存（由内核提供），从中分割出小块满足申请需求，并处理释放和复用</p>
<p>它的底层实现依赖于C库（glibc），不直接操作物理内存，而是通过系统调用管理进程虚拟地址空间，整个过程分为2步：</p>
<ul>
<li>C库的内存管理器：它向内核“批发”大块内存（heap），然后自己设计算法（基于free list）来管理（分割、合并、分配、回收）这些内存，回应程序的 <code>malloc/free</code>请求。目标是速度快、碎片少</li>
<li>操作系统内核：负责“批发”和“映射”。它通过 <code>brk</code>和 <code>mmap</code>系统调用，为进程分配和映射虚拟内存页。目标是安全、隔离</li>
</ul>
<p>11.realloc的底层原理</p>
<p><code>realloc</code>的根本目的是<strong>改变一块已分配内存的大小</strong>。它的核心智能在于会根据新旧内存块的大小和位置，选择最高效的策略来完成调整，其行为可以概括为以下三种情况：</p>
<ul>
<li>原地扩大：如果当前内存块后面的相邻空间是空闲的且足够大，可以直接扩展当前块，无需移动数据。这是最理想、最高效的情况</li>
<li>原地缩小：直接缩小当前块的大小，多余的部分会被释放并交还给内存管理器，放入空闲链表以供后续分配。也无需移动数据</li>
<li>异地重新分配：如果无法原地扩大，<code>realloc</code>会执行“分配新空间 -&gt; 拷贝旧数据 -&gt; 释放旧空间”的完整流程。这是开销最大的情况</li>
</ul>
<p>12.malloc和realloc的本质区别是什么</p>
<ul>
<li>malloc的核心是开辟一块新内存，而realloc的核心是调整一块已分配的内存，不一定会分配新的内存</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>1.用过智能指针吗？一般用在什么地方？</p>
<p>2.用智能指针时需要注意什么？</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>1.对STL有了解吗？用过哪些</p>
<p>2.vector和list有哪些区别</p>
<p>3.list是单链表还是双链表</p>
<p>4.用过STL的函数吗？std::sort是哪个排序</p>
<p>5.vector和list的sort是一样的吗</p>
<p>6.map和set都是有序的吗</p>
<p>7.unordered-map和map的底层实现是什么</p>
<p>8.STL是不是线程安全的？</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>1.C++的多态是怎么实现的</p>
<p>多态通常是使用父类指针指向子类对象&#x2F;引用时触发，核心是<strong>虚函数</strong> + <strong>虚函数表</strong></p>
<ul>
<li>每个包含虚函数的类，编译器会生成一个<strong>虚函数表</strong>，本质上是个<strong>函数指针数组</strong><ul>
<li>虚函数本身放在<code>.text</code>，但是虚函数表放在<code>.rodata</code></li>
</ul>
</li>
<li>编译器给每个对象生成一个虚表指针（vptr），指向所属类的 vtable</li>
<li>当调用虚函数时，通过对象里的 vptr → 找到 vtable → 调用函数指针 → 跳转到 <code>.text</code> 段执行</li>
</ul>
<p>2.C语言如何面向对象中成员函数的那种效果</p>
<ul>
<li>结构体 + 函数指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">set</span>)(<span class="keyword">struct</span> Point* self, <span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">    <span class="type">void</span> (*print)(<span class="keyword">struct</span> Point* self);</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Point_set</span><span class="params">(Point* self, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    self-&gt;x = x;</span><br><span class="line">    self-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Point_print</span><span class="params">(Point* self)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>, self-&gt;x, self-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point p = &#123;<span class="number">0</span>, <span class="number">0</span>, Point_set, Point_print&#125;; <span class="comment">// 初始化时绑定函数</span></span><br><span class="line">    p.<span class="built_in">set</span>(&amp;p, <span class="number">10</span>, <span class="number">20</span>);   <span class="comment">// 调用方式像成员函数</span></span><br><span class="line">    p.print(&amp;p);         <span class="comment">// 输出 (10, 20)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.如果用C语言实现C++的成员变量的权限要怎么实现</p>
<ul>
<li>隐藏实现（不透明指针）：只在 <code>.c</code> 文件里定义结构体完整内容，在 <code>.h</code> 文件里只声明 <code>struct</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OpaqueType</span> <span class="title">OpaqueType</span>;</span>   <span class="comment">// 只声明，不定义</span></span><br><span class="line">OpaqueType* <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(OpaqueType* obj)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_something</span><span class="params">(OpaqueType* obj)</span>;</span><br><span class="line"><span class="comment">// api.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpaqueType</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> secret;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line">OpaqueType* <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OpaqueType));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(OpaqueType* obj)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_something</span><span class="params">(OpaqueType* obj)</span> &#123;</span><br><span class="line">    obj-&gt;secret = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>api.h</code> 中，外部用户只能拿到 <code>OpaqueType*</code>，不能直接访问 <code>struct</code> 里的 <code>secret</code> 和 <code>name</code>，这就是<strong>不透明指针</strong></p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>1.指针函数和函数指针有什么区别</p>
<p>2.什么情况下会用到函数指针</p>
<p>3.当struct数组的指针+1时，实际增加了多少字节</p>
<p>4.如何使用指针去操作内存？</p>
<p>5.使用指针如何避免越界访问？</p>
<h2 id="C-11杂项"><a href="#C-11杂项" class="headerlink" title="C++11杂项"></a>C++11杂项</h2><p>1.右值引用是什么</p>
<p>2.std::async()的原理知道吗？是用什么实现的？（协程）知道异步执行的原理吗</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote>
<p>元素按顺序排列，只有一个前驱和一个后继（首尾元素除外）</p>
</blockquote>
<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>1.数组</p>
<ul>
<li>介绍：在内存中分配一段连续的存储空间，用于存储相同类型的数据元素。通过索引（下标）可以随机访问任何元素</li>
<li>优点：随机访问速度快（时间复杂度 O(1)）</li>
<li>缺点：大小固定（静态数组），插入和删除元素效率低（可能需要移动大量元素，时间复杂度 O(n)）</li>
<li>使用场景：<ul>
<li>需要频繁通过索引查询数据。例如，存如传感器校准值、PID参数、字体点阵、正弦波表等</li>
<li>处理固定大小的集合例如，存储图片的像素矩阵</li>
<li>作为其他复杂数据结构的基础（如堆、哈希表）</li>
</ul>
</li>
</ul>
<p>2.链表</p>
<ul>
<li>介绍：由一系列节点组成，每个节点包含数据和指向下一个节点的指针。在内存中是非连续的</li>
<li>优点：大小动态可变，插入和删除效率高（只需修改指针，时间复杂度 O(1)，但查找位置需要 O(n)）</li>
<li>缺点：无法随机访问，查找效率低（时间复杂度 O(n)）；需要额外的空间存储指针</li>
<li>变体：<ul>
<li>单向链表：节点只指向下一个节点</li>
<li>双向链表：节点指向前一个和后一个节点，支持反向遍历</li>
<li>循环链表：尾节点指向头节点，形成环</li>
</ul>
</li>
<li>使用场景：<ul>
<li>需要频繁插入和删除，但较少随机访问的场景。例如：实现栈、队列、双向队列</li>
<li>浏览器的“前进”、“后退”功能（双向链表）</li>
<li>操作系统的进程调度队列</li>
<li>LRU（最近最少使用）缓存淘汰算法（结合哈希表）</li>
</ul>
</li>
</ul>
<p>3.栈</p>
<ul>
<li>介绍：一种后进先出的线性结构。只能在一端（栈顶）进行插入（压栈）和删除（弹栈）操作</li>
<li>特点：访问受限，操作简单高效</li>
<li>使用场景：<ul>
<li>函数调用栈：硬件自动使用栈来保存返回地址、局部变量、函数参数。这是栈最根本的应用</li>
<li>上下文切换：RTOS在进行任务调度时，将当前任务的上下文（寄存器值等）压入其专属的任务栈中</li>
<li>表达式求值：检查括号匹配、将中缀表达式转换为后缀表达式</li>
<li>撤销&#x2F;重做功能：将操作压栈，撤销时弹栈</li>
<li>浏览器的历史记录（点击后退按钮）</li>
</ul>
</li>
</ul>
<p>4.队列</p>
<ul>
<li>介绍：一种先进先出的线性结构。在一端（队尾）插入，在另一端（队头）删除</li>
<li>特点：访问受限，操作简单高效</li>
<li>变体：<ul>
<li>双端队列：两端都可以进行插入和删除</li>
<li>优先队列：出队顺序按优先级而非入队顺序，通常用堆实现</li>
</ul>
</li>
<li>使用场景：<ul>
<li>需要按顺序处理的场景。例如：消息队列、任务队列（如打印机作业排队）</li>
<li>广度优先搜索（BFS）算法，多线程的阻塞队列</li>
</ul>
</li>
</ul>
<h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><blockquote>
<p>元素之间不存在简单的顺序关系，一个元素可能有多个前驱或后继</p>
</blockquote>
<p>1.树：一种分层级的非线性结构，由节点和边组成。每个节点有零个或多个子节点</p>
<ul>
<li><p>二叉树：每个节点最多有两个子节点（左、右）</p>
</li>
<li><p>满二叉树：只有度为0的结点和度为2的结点，并且度为0的结点在同一层上。深度为k的满二叉树有2^k-1个节点</p>
</li>
</ul>
<img src="..\..\assets\image-20250918145035501.png" alt="image-20250918145035501" style="zoom:33%;" />

<ul>
<li>完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置<ul>
<li>特性：因为没有空位，所以可以用数组存储（按层序遍历的顺序）</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">关系</th>
<th align="left">计算公式</th>
<th align="left">例子（i&#x3D;2）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">父节点</td>
<td align="left"><code>parent(i) = (i - 1) / 2</code></td>
<td align="left"><code>(2-1)/2 = 0</code></td>
</tr>
<tr>
<td align="left">左孩子</td>
<td align="left"><code>left_child(i) = 2*i + 1</code></td>
<td align="left"><code>2 * 2+1 = 5</code></td>
</tr>
<tr>
<td align="left">右孩子</td>
<td align="left"><code>right_child(i) = 2*i + 2</code></td>
<td align="left"><code>2 * 2+2 = 6</code></td>
</tr>
</tbody></table>
<img src="..\..\assets\image-20250918145045672.png" alt="image-20250918145045672" style="zoom: 67%;" />

<ul>
<li><p>二叉搜索树（BST）：每个节点<strong>有数值</strong>，是个有序树：左子树所有节点的值 &lt; 根节点的值 &lt; 右子树所有节点的值；左右子树都是二叉搜索树</p>
<ul>
<li>特性：利用<strong>中序</strong>遍历得到的数组，是升序的</li>
<li>使用场景：动态数据集合的快速查找、插入、删除（平均 O(log n)）。用于实现集合、映射（字典）</li>
</ul>
</li>
<li><p>平衡二叉搜索树（AVL树&#x2F;红黑树）：它是一棵空树或它的左右两个子树的<strong>高度差</strong>的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</p>
<img src="..\..\assets\image-20250918145355080.png" alt="image-20250918145355080" style="zoom:67%;" />

<ul>
<li><p>红黑树：在每次插入节点后，通过旋转或重新着色来主动调整树结构，是其始终保持平衡的结构，用于解决BST退化成链表的问题，保证在最坏的情况下增删改查的性能为O(logn)</p>
</li>
<li><p>AVL树：当插入或删除一个节点后，可能会使得某个节点的平衡因子的绝对值大于1，这时就需要通过旋转来调整树的结构，使其重新平衡</p>
</li>
<li><p>使用场景：在需要保证最坏情况下性能的场景，如数据库索引、Java中的 <code>TreeMap</code>、<code>TreeSet</code></p>
</li>
</ul>
</li>
<li><p>堆：一种特殊的<strong>完全二叉树</strong>，父节点的值总是大于等于（大顶堆）或小于等于（小顶堆）子节点的值</p>
<ul>
<li>使用场景：<ul>
<li>用于实现​​STL的优先队列​​(<code>priority_queue</code>)</li>
<li>在RTOS中，任务调度器通常使用​​优先队列​​来决定下一个运行的最高优先级就绪任务</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>2.图</p>
<ul>
<li><p>存储方式：主要有2种</p>
<ul>
<li>邻接矩阵：一个二维矩阵</li>
<li>邻接表：还是个二维数组，每一行代表一个独立的节点，后边的每一列代表与该节点直接相连的节点</li>
</ul>
</li>
<li><p>什么时候用DFS、什么时候用BFS</p>
<ul>
<li>DFS：适合寻找所有路径、回溯问题、连通性检测。邻接表写法如下（如果是棋盘格，则不是该写法）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x：目前遍历的节点</span></span><br><span class="line"><span class="comment">// n：终点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> x, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当前遍历的节点x 到达节点n </span></span><br><span class="line">    <span class="keyword">if</span> (x == n) &#123; <span class="comment">// 找到符合条件的一条路径</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历节点x链接的所有节点</span></span><br><span class="line">        <span class="keyword">if</span> (grid[x][i] == <span class="number">1</span>) &#123; <span class="comment">// 找到 x链接的节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 遍历到的节点加入到路径中来</span></span><br><span class="line">            <span class="built_in">dfs</span>(grid, i, n); <span class="comment">// 进入下一层递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销本节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BFS：适合最短路径、层级遍历、最近邻搜索。常见函数形式：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// grid 是地图，也就是一个二维数组</span></span><br><span class="line"><span class="comment">// visited标记访问过的节点，不要重复访问</span></span><br><span class="line"><span class="comment">// x,y 表示开始搜索节点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que; <span class="comment">// 定义队列</span></span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;); <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记为访问过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123; <span class="comment">// 开始遍历队列里的元素</span></span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>(); <span class="comment">// 从队列取元素</span></span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second; <span class="comment">// 当前节点坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 开始想当前节点的四个方向左右上下去遍历</span></span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>]; <span class="comment">// 获取周边四个方向的坐标</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || </span><br><span class="line">                nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) </span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">// 坐标越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 如果节点没被访问过</span></span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);  <span class="comment">// 队列添加该节点为下一轮要遍历的节点</span></span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记，避免重复访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>什么时候需要使用visited矩阵</p>
<ul>
<li>图遍历基本上都需要，如果图有环，没有visited矩阵就出不来了</li>
</ul>
</li>
</ul>
<h3 id="其他数据结构"><a href="#其他数据结构" class="headerlink" title="其他数据结构"></a>其他数据结构</h3><p>1.哈希表：通过哈希函数将键映射到数组中的一个位置来访问记录，以实现 O(1) 时间复杂度的平均查找速度。</p>
<ul>
<li>优点：查找、插入、删除速度极快（平均情况下）</li>
<li>缺点：哈希冲突；遍历顺序不确定；最坏情况下性能退化到 O(n)</li>
<li>使用场景：需要快速查找、插入、删除的场景。例如：<ul>
<li>实现字典、集合（如Python的 <code>dict</code>，Java的 <code>HashMap</code>）</li>
<li>缓存（如Memcached、Redis）</li>
<li>快速去重</li>
</ul>
</li>
</ul>
<p>2.跳表：在有序链表的基础上添加了多级索引，以提高查找效率。可以视为一种“以空间换时间”的算法</p>
<ul>
<li>特点：实现相对简单，效率与平衡树媲美（查找、插入、删除平均 O(log n)）</li>
<li>使用场景：<ul>
<li>Redis中的有序集合（Sorted Set）实现</li>
</ul>
</li>
</ul>
<h3 id="面试问题-2"><a href="#面试问题-2" class="headerlink" title="面试问题"></a>面试问题</h3><p>1.哈希表的实现原理</p>
<ul>
<li>哈希表的核心思想是 “基于键的快速随机访问”，它通过一个函数将键（Key）直接映射到一个存储位置，从而在平均情况下实现O(1)时间复杂度的插入、删除和查找。它的核心包括3个部分：<ul>
<li>哈希函数：接收一个键（Key）作为输入，经过计算，输出一个整数（哈希值）</li>
<li>哈希桶：这是一个数组，大小通常为质数（为了取模时更均匀），每个元素是一个存储位置</li>
<li>冲突解决：不同的 key 可能被哈希函数映射到同一个地址，这叫哈希冲突。解决冲突是哈希表的关键</li>
</ul>
</li>
</ul>
<p>2.平衡二叉树的实现原理</p>
<ul>
<li>有多种实现方式，常见的有红黑树和AVL树，通过每次插入新节点之后调整树的结构来使其一直保持近似平衡，主要是为了解决退化成链表的问题</li>
</ul>
<p>3.你之前用过哪些数据结构</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归的三要素：</p>
<ul>
<li>1.确定递归函数的参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型</li>
<li>2.确定终止条件：写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出</li>
<li>3.确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程</li>
</ul>
<p>最简单的递归例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>回溯是通过<strong>递归</strong>来实现的，其本质是<strong>穷举</strong>所有可能，最多再加一些剪枝操作，所以性能一般很差。回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出K个数的集合</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p>回溯法一般都可以抽象成树形结构（N叉树），它解决的问题一般是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就构成了树的深度</p>
<p><img src="....%5Cassets%5Cimage-20250918151420830.png" alt="image-20250918151420830"></p>
<p>回溯算法模板：</p>
<ul>
<li>回溯函数模板返回值以及参数<ul>
<li>一般返回值是<code>void</code></li>
<li>参数里一般都有for循环用的<code>startIndex</code></li>
</ul>
</li>
<li>回溯函数终止条件<ul>
<li>一般是到达叶子节点</li>
</ul>
</li>
<li>回溯搜索的遍历过程（for循环嵌递归）<ul>
<li>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>贪心的本质是选择每一阶段的<strong>局部最优</strong>，从而达到<strong>全局最优</strong>。贪心没有状态推导，而是从局部直接选最优的</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>相比于贪心，动态规划中每一个状态一定是由上一个状态推导出来的</p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><table>
<thead>
<tr>
<th align="left">排序算法</th>
<th align="left">平均时间复杂度</th>
<th align="left">最坏时间复杂度</th>
<th align="left">最好时间复杂度</th>
<th align="left">空间复杂度</th>
<th align="left">是否稳定</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">冒泡排序</td>
<td align="left">O(n²)</td>
<td align="left">O(n²)</td>
<td align="left">O(n)</td>
<td align="left">O(1)</td>
<td align="left">稳定</td>
<td align="left">小规模数据、教学示例</td>
</tr>
<tr>
<td align="left">选择排序</td>
<td align="left">O(n²)</td>
<td align="left">O(n²)</td>
<td align="left">O(n²)</td>
<td align="left">O(1)</td>
<td align="left">不稳定</td>
<td align="left">交换次数少、小规模数据</td>
</tr>
<tr>
<td align="left">插入排序</td>
<td align="left">O(n²)</td>
<td align="left">O(n²)</td>
<td align="left">O(n)</td>
<td align="left">O(1)</td>
<td align="left">稳定</td>
<td align="left">小规模、基本有序的数据</td>
</tr>
<tr>
<td align="left">快速排序</td>
<td align="left">O(n log n)</td>
<td align="left">O(n²)</td>
<td align="left">O(n log n)</td>
<td align="left">O(log n)</td>
<td align="left">不稳定</td>
<td align="left">大规模数据、内存排序</td>
</tr>
<tr>
<td align="left">归并排序</td>
<td align="left">O(n log n)</td>
<td align="left">O(n log n)</td>
<td align="left">O(n log n)</td>
<td align="left">O(n)</td>
<td align="left">稳定</td>
<td align="left">外部排序（磁盘数据）、链表排序</td>
</tr>
<tr>
<td align="left">堆排序</td>
<td align="left">O(n log n)</td>
<td align="left">O(n log n)</td>
<td align="left">O(n log n)</td>
<td align="left">O(1)</td>
<td align="left">不稳定</td>
<td align="left">大规模数据、内存受限场景</td>
</tr>
<tr>
<td align="left">希尔排序</td>
<td align="left">O(n log n)</td>
<td align="left">O(n²)</td>
<td align="left">O(n log n)</td>
<td align="left">O(1)</td>
<td align="left">不稳定</td>
<td align="left">中等规模数据、改进的插入排序</td>
</tr>
<tr>
<td align="left">计数排序</td>
<td align="left">O(n + k)</td>
<td align="left">O(n + k)</td>
<td align="left">O(n + k)</td>
<td align="left">O(n + k)</td>
<td align="left">稳定</td>
<td align="left">非负整数、范围较小的数据</td>
</tr>
<tr>
<td align="left">桶排序</td>
<td align="left">O(n + k)</td>
<td align="left">O(n²)</td>
<td align="left">O(n)</td>
<td align="left">O(n + k)</td>
<td align="left">稳定</td>
<td align="left">均匀分布的数据</td>
</tr>
<tr>
<td align="left">基数排序</td>
<td align="left">O(n × k)</td>
<td align="left">O(n × k)</td>
<td align="left">O(n × k)</td>
<td align="left">O(n + k)</td>
<td align="left">稳定</td>
<td align="left">整数或字符串排序</td>
</tr>
</tbody></table>
<p>1.选择排序：多次遍历数据，每次都找到<strong>最小</strong>元素然后把他放到无序数据的左边(直接用swap)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">select_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[min_idx])</span><br><span class="line">                min_idx = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[min_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.冒泡排序：不断把<strong>较大</strong>的元素移到右边，通过交换 <code>arr[sortedIndex]</code> 右侧的逆序对完成排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j<span class="number">+1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j<span class="number">+1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.插入排序：将未排序部分的元素逐个插入到已排序部分的正确位置，类似于整理扑克牌</p>
<p>算法思路：</p>
<p>(1)初始状态：数组的第一个元素视为已排序部分，其余部分视为未排序</p>
<p>(2)遍历未排序部分：从第二个元素开始，逐个取出元素</p>
<p>(3)插入到正确位置：</p>
<ul>
<li>将该元素与已排序部分的元素<strong>从后向前</strong>比较</li>
<li>如果当前元素比已排序部分的某个元素小，则将该元素后移一位</li>
<li>直到找到合适的位置，插入当前元素</li>
</ul>
<p>(4)重复执行，直到所有元素都被插入到正确位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;       <span class="comment">// 从第二个元素开始</span></span><br><span class="line">        <span class="type">int</span> key = arr[i];               <span class="comment">// 当前待插入元素</span></span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;                  <span class="comment">// 已排序部分的最后一个元素索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后向前比较，找到合适的插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];        <span class="comment">// 比 key 大的元素后移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;              <span class="comment">// 插入 key 到正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.快速排序：</p>
<ul>
<li>首先选择一个基准元素<code>pivot</code>（最左&#x2F;最右&#x2F;随机…）对数据进行分区（partition），不断调整元素位置使得左侧的数据都小于这个基准元素、右侧的数据都大于这个基准元素</li>
<li>然后对左侧和右侧的数组递归进行快速排序</li>
</ul>
<p>代码思路：</p>
<ul>
<li>指针 <code>i</code>：记录“已处理的≤<code>pivot</code>部分”的最后一个位置</li>
<li>指针 <code>j</code>：从左到右扫描数组，检查每个元素是否应该放到左边</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分区函数，返回基准的最终位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[right];  <span class="comment">// 选择最后一个元素作为基准的初始值</span></span><br><span class="line">    <span class="type">int</span> i = left - <span class="number">1</span>;        <span class="comment">// i最后会指向左边部分的末尾,这里只是初始化一下</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//`j`从左到右扫描，如果 `nums[j] &lt;= pivot`，就交换 `nums[++i]`和 `nums[j]`</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);  <span class="comment">// 将小于基准的元素移到左边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[right]);   <span class="comment">// 将基准放到正确的位置</span></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(arr, left, right);  <span class="comment">// 获取基准位置</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, left, pivotIndex - <span class="number">1</span>);         <span class="comment">// 递归排序左半部分</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pivotIndex + <span class="number">1</span>, right);        <span class="comment">// 递归排序右半部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.归并排序</p>
<p>归并排序是一种分治法排序算法，核心思想是将数组分成两半，分别排序后再合并。它的时间复杂度稳定为 O(n log n)，是稳定排序（相等元素的相对顺序不会改变），但需要 O(n) 的额外空间</p>
<p>归并排序分为两个主要阶段：</p>
<p>1.分（Divide）：递归地将数组分成两半，直到每个子数组只有一个元素（此时天然有序）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原始数组：[38, 27, 43, 3, 9, 82, 10]</span><br><span class="line">第一次分割：左 [38, 27, 43, 3] | 右 [9, 82, 10]</span><br><span class="line">第二次分割：</span><br><span class="line">  左 [38, 27] | 右 [43, 3]</span><br><span class="line">  左 [9, 82] | 右 [10]</span><br><span class="line">第三次分割：</span><br><span class="line">  左 [38] | 右 [27]</span><br><span class="line">  左 [43] | 右 [3]</span><br><span class="line">  左 [9] | 右 [82]</span><br><span class="line">  左 [10]</span><br></pre></td></tr></table></figure>

<p>2.治（Merge）：将两个有序子数组合并成一个更大的有序数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 合并 [38] 和 [27] → [27, 38]</span><br><span class="line">2. 合并 [43] 和 [3] → [3, 43]</span><br><span class="line">3. 合并 [27, 38] 和 [3, 43] → [3, 27, 38, 43]</span><br><span class="line">4. 合并 [9] 和 [82] → [9, 82]</span><br><span class="line">5. 合并 [9, 82] 和 [10] → [9, 10, 82]</span><br><span class="line">6. 最终合并 [3, 27, 38, 43] 和 [9, 10, 82] → [3, 9, 10, 27, 38, 43, 82]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(right - left + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid &amp;&amp; j &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[j])</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid)</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; right)</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>;n&lt;temp.<span class="built_in">size</span>();++n)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[left + n] = temp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, left, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="built_in">merge</span>(nums, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://Li-Ruiqi777.github.io">Li Ruiqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://li-ruiqi777.github.io/03-C++/00-C++%E9%9D%A2%E7%BB%8F.html">https://li-ruiqi777.github.io/03-C++/00-C++%E9%9D%A2%E7%BB%8F.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/04-Linux/01-Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/08-pkg-config.html" title="08 pkg config"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">08 pkg config</div></div><div class="info-2"><div class="info-item-1">pkg-configpkg-config是一个命令行工具，使用它可以快速查看当前环境中安装了哪些第三方库，方便在一个库没提供.cmake文件时链接该库 核心用法12345678910pkg-config --list-all # 列出所有库pkg-config --modversion 库名  # 查看版本pkg-config --cflags 库名     # 查看编译标志pkg-config --libs 库名       # 查看链接标志pkg-config --variable=libdir 库名  # 库文件目录pkg-config --variable=includedir 库名  # 头文件目录pkg-config --variable pc_path pkg-config    注意事项 不是所有库都注册了 pkg-config 信息，有些库可能没有 .pc 文件，但是使用apt安装的带-dev的包一般都带.pc文件 如果找不到某个库，可能是因为： 库确实没有安装 库没有提供 .pc 文件 .pc 文件不在 pkg-config 的搜索路径中   你可以通过设置...</div></div></div></a><a class="pagination-related" href="/02-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/wsl.html" title="wsl"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">wsl</div></div><div class="info-2"><div class="info-item-1">WSL遇到的问题1.开启WSL2后，VMWare老卡死   VMware虚拟机经常性卡死，打开运行一段时间后卡死 WSL、Docker、Hyper-V、VMWare共存方案  WSL2和VMWare因为Hyper-V虚拟化的原因，不能很好的共存，如果要开启WSL2的话，就得开启Hyper-V虚拟化，这可能导致VMWare运行的时候卡死。所以如果要用VMWare的话，就暂时把Hyper-V关了吧 Hyper-V开&#x2F;关方法： 1234# 开启：bcdedit /set hypervisorlaunchtype auto # 然后重启# 关闭：bcdedit /set hypervisorlaunchtype off # 然后重启  重启后可以在终端中输入wsl验证，如果不能进ubuntu的终端，就说明关闭成功了 </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Li Ruiqi</div><div class="author-info-description">总有低谷</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">157</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Li-Ruiqi777"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Li-Ruiqi777" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1009962019@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-C-%E5%85%AB%E8%82%A1"><span class="toc-number">1.</span> <span class="toc-text">C&#x2F;C++八股</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.</span> <span class="toc-text">关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">1.1.1.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">1.1.2.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#define"><span class="toc-number">1.1.3.</span> <span class="toc-text">#define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#union"><span class="toc-number">1.1.4.</span> <span class="toc-text">union</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typedef"><span class="toc-number">1.1.5.</span> <span class="toc-text">typedef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">1.1.6.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#register"><span class="toc-number">1.1.7.</span> <span class="toc-text">register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inline"><span class="toc-number">1.1.8.</span> <span class="toc-text">inline</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">面试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-number">1.3.1.</span> <span class="toc-text">内存对齐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">结构体内存对齐</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-number">1.3.2.</span> <span class="toc-text">类的内存分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E6%AE%B5"><span class="toc-number">1.3.3.</span> <span class="toc-text">位段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF"><span class="toc-number">1.3.4.</span> <span class="toc-text">大小端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-1"><span class="toc-number">1.3.5.</span> <span class="toc-text">面试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.4.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL"><span class="toc-number">1.5.</span> <span class="toc-text">STL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.7.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E6%9D%82%E9%A1%B9"><span class="toc-number">1.8.</span> <span class="toc-text">C++11杂项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.1.</span> <span class="toc-text">线性结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.2.</span> <span class="toc-text">非线性结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.3.</span> <span class="toc-text">其他数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-2"><span class="toc-number">1.9.4.</span> <span class="toc-text">面试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.10.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">1.10.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">1.10.2.</span> <span class="toc-text">回溯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">1.10.3.</span> <span class="toc-text">贪心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.10.4.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">1.10.5.</span> <span class="toc-text">搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.10.6.</span> <span class="toc-text">排序</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Li Ruiqi</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">人因梦想而伟大</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>